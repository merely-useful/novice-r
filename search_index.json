[["index.html", "Merely Useful: An introduction to using R Chapter 1 Overview 1.1 Why isn’t all of this normal already? 1.2 Contributing 1.3 Acknowledgments 1.4 Goals of this course", " Merely Useful: An introduction to using R Madeleine Bonsma-Fisher, Kate Hertweck, Damien Irving, Luke Johnston, Christina Koch, Sara Mahallati, Joel Ostblom, Elizabeth Wickes, Charlotte Wickham, and Greg Wilson 2021-05-03 Chapter 1 Overview NOTE: This book is very much in-development so many parts are incomplete, as a draft, or not even started. Check back later! It’s still magic even if you know how it’s done. — Terry Pratchett FIXME: general introduction Be able to do the steps in Yenni et al. (2019). 1.1 Why isn’t all of this normal already? Nobody argues that research should be irreproducible or unsustainable, but “not against it” and actively supporting it are very different things. Academia doesn’t yet know how to reward people for writing useful software, so while you may be thanked, the extra effort you put in may not translate into job security or decent pay. And some people still argue against openness, Being open is a big step toward a (non-academic) career path, which is where approximately 80% of PhDs go, and for those staying in academia, open work is cited more often than closed (FIXME: citation). However, some people still worry that if they make their data and code generally available, someone else will use it and publish a result they have come up with themselves. This is almost unheard of in practice, but that doesn’t stop people using it as a boogeyman. Other people are afraid of looking foolish or incompetent by sharing code that might contain bugs. This isn’t just impostor syndrome: members of marginalized groups are frequently judged more harshly than others (FIXME: citation). 1.2 Contributing If you want to contribute, please check out the CONTRIBUTING guidelines. 1.3 Acknowledgments This book owes its existence to the hundreds of researchers we met through the Carpentries. We are also grateful to Insight Data Science for sponsoring the early stages of this work, to everyone who has contributed, and to: Practical Computing for Biologists Haddock and Dunn (2010) Effective Computation in Physics Scopatz and Huff (2015) “A Quick Guide to Organizing Computational Biology Projects” Noble (2009) “Ten Simple Rules for Making Research Software More Robust” Taschuk and Wilson (2017) “Best Practices for Scientific Computing” Wilson et al. (2014) “Good Enough Practices in Scientific Computing” Wilson et al. (2017) 1.4 Goals of this course This outline describes the questions that the novice courses on R and Python will answer. The advanced course can then assume that learners have hands-on experience with these topics but nothing more. 1.4.1 Personas 1.4.1.1 Anya Anya is a professor of neuropsychology who is responsible for teaching her department’s introduction to statistics to 1100 first-year students every year. (Students complain that the Stats department’s introductory course is too theoretical and requires more programming knowledge than they have.) When she finds time for it, her research focuses on color perception in infants. Over the past nine years, Anya has designed and run a dozen experiments on 50-100 infant subjects each and analyzed the results using SPSS and more recently R (which she taught herself during a sabbatical). She has never taken a programming course, and suffers from impostor syndrome when talking to colleagues who are using things like GitHub and R Markdown. Anya would like to figure out how to use R to teach her intro stats course, which currently uses a mixture of Excel and SPSS. She would like to learn more about time series analysis to support her research, and about tools like Git and R Markdown. This guide has modular lessons and exercises that she can adapt to use in her course, and suggestions for how to make learning interactive with a large class size. She also finds helpful instructions for applying time series analysis to data using R. 1.4.1.2 Exton Exton taught business at a community college before joining a friend’s startup, and now does community management for a company that builds healthcare software. He still teaches Marketing 101 every year to help people with backgrounds like his. Exton uses Excel to keep track of who is registered for webinars, workshops, and training sessions. Some of these spreadsheets are created from CSV files produced by a web-scraping script a summer intern wrote for him a couple of years ago. Exton doesn’t think of himself as a programmer, but spends hours creating complicated lookup tables in multi-sheet spreadsheets to help him figure out how many webinar attendees turn into community contributors, who answers forum posts most frequently, and so on. Exton knows there are better ways to do what he’s doing, but feels overwhelmed by the flood of blog posts, tweets, and “helpful” recommendations he receives from members of the company’s engineering team. He wants someone to tell him where he should start and how long it will take whatever he learns to pay off. Exton finds ‘Merely Useful’ after some Googling, and sees an example of data analysis with spreadsheet data that looks really similar to what he’s trying to do. He carefully works through that particular example, then goes back and works through some of the earlier material in the book. He can tell that it won’t take long to get this to work with his data. 1.4.1.3 Irwin Irwin, 18, is five months into an undergraduate degree in urban planning. He’s read lots of gushing articles in Wired about data science, and was excited by the prospect of learning how to do it, but dropped his CS 101 course after six weeks because nothing made sense. (His university’s computer science department uses Haskell as an introductory programming language…) He is doing better in Anya’s course (which he is taking as an elective) but still spends most of his time copying, pasting, and swearing. Irwin did well in his high school math classes, and built himself a home page with HTML and CSS in a weekend workshop in grade 11. He knows how to do simple calculations in Excel, has accounts on nine different social media sites, and attends all of his morning classes online. Anya mentions this guide in one of her classes, and Irwin downloads the PDF to read on the bus. He loves the examples that use urban data, and right away he has tons of ideas about where to get more cool data to analyze. His urban data science blog is already taking shape in his head. 1.4.1.4 Camilla Camilla recently started a job as an assistant professor. Her department (Medieval Studies) is trying to develop a digital humanities data-science-heavy undergraduate program, and the undergraduate chair thinks that Camilla has the most programming experience in the department and has asked her to develop an introduction to programming course for humanities students. Camilla has dabbled in natural language processing and has learned Python over the course of her previous work, but she has no experience teaching progamming and she’s not sure what the best way is to teach beginners. She doesn’t want to start from scratch to create a course out of nothing. She also isn’t sure which programming language the new program should focus on. She finds ‘Merely Useful’ and feels relieved: she can pretty much use the book as-is for her course. She looks up the examples of text and image analysis and compares how both R and Python approach those kinds of data to help her make a decision about which language to teach. 1.4.1.5 Jordan Jordan is a third-year undergraduate student in ecology. Two months ago she started working part-time for a professor in her department, and she’s beginning to collect and analyze data from her own experiments with fruit flies. Her professor has asked her to learn R to do her analysis and suggested that she sign up for the introduction to quantitative data analysis in R course that the ecology department offers. The course is just starting, and it uses ‘Merely Useful’ as the textbook. Jordan can’t wait to apply her new programming knowledge to her data, so she starts reading ahead and trying to use her own data in some of the book’s examples. As she works through examples, she realizes that she’ll need to change a few things about how she records her data in spreadsheets so that it will be easier to analyze in R. 1.4.2 Outline 1.4.2.1 Getting started What are the different ways I can interact with software? console scripts How can I find and view help? In the IDE Stack Overflow How can I inspect data while I’m working on it? table viewers 1.4.2.2 Data manipulation How can I read tabular data into a program? what CSV is, where it comes from, and why people use it reading files How can I select subsets of my data? select filter arrange Boolean conditions How can I calculate new values? mutate ifelse How can I tell what’s gone wrong in my programs? reading error messages the difference between syntax and runtime errors How can I operate on subsets of my data? group summarize split-apply-combine How can I work with two or more datasets? join How can I save my results? writing files What isn’t included? anything other than reasonably tidy tabular data map loops and conditionals 1.4.2.3 Plotting Why plot? summary statistics can mislead [Anscombe’s Quartet and the DataSaurus dozen][anscombe-datasaurus] What are the core elements of every plot? data geometric objects aesthetic mapping How can I create different kinds of plots? scatter plot line plot histogram bar plot which to use when How can I plot multiple datasets at once? grouping faceting How can I make misleading plots? showing a single central tendency data point instead of the individual observations saturated plots instead of for example violins or 2D histograms picking unreasonable axes limits to intentionally misrepresent the underlying data not using perceptually uniform colormaps to indicate quantities not thinking about color blindness What isn’t included? outliers interactive plots maps 3D visualization 1.4.2.4 Development How can I make my own functions? declaring functions declaring parameters default values common conventions How can I make my programs tell me that something has gone wrong? validation (did we build the right thing) vs. verification (did we build the thing correctly) assertions for sanity checks How can I ask for help? creating a reproducible example (reprex) How do I install software? what is a package? package manager What isn’t included? code browsers, multiple cursors, and other fancy IDE tricks virtual environments debuggers 1.4.2.5 Data analysis How can I represent and manage missing values? NA Python Learning Objectives Identify missing values (e.g., NaN) in your datasets Examine the impact of missing valus on your datasets Demonstrate and use commands that process missing values Demonstrate how to replace missing values Python Lecture Notes (general info) Missing Completely at Random (MCAR) Missing at Random (MAR) Missing Not at Random (MNAR) Missing data at scale (what’s a little and what’s alot?) Imputation and Multiple Imputation When summing the data, missing values will be treated as zero If all values are missing, the sum will be equal to NaN cumsum() and cumprod() methods ignore missing values but preserve them in the resulting arrays .groupby() method see more in descriptive stats section Missing values in .groupby() method are excluded (just like in R) Another .groupby() fun fact: .groupby() with observed=True includes NaNs for categoricals. Many descriptive statistics methods have skipna option to control if missing data should be excluded . This value is set to True by default (unlike R) Python Lecture Notes (useful commands) Table: df.method() / description dropna() / drop missing observations dropna(how=‘all’) / drop observations where all cells are NA dropna(axis=1,how=‘all’) / drop coloumn if all values are missing dropna(thresh=5) / drop rows that contain less than 5 non-missing values fillna(0) / replace missing values with zeros isna() returns True if the value is missing notna() / Returns True for non-missing values T/F Exercises (#Review4Everybody) Imputation is really just making up data to artificially inflate results. It’s better to just drop cases with missing data than to impute. (need descriptive stats lesson first) I can just impute the mean for any missing data. It won’t affect results, and improves power. Missing data isn’t really a problem if I’m just doing simple statistics. When imputing, it’s important that the imputations be plausible data points. Short Answer Exercises (#Review4Everybody) What is imputation of missing data? How does missing values affect results? How do you computationally mark missing values in your dataset? How could you handle missing data? How can I get a feel for my data? summary/descrptive statistics Python Learning Objectives Recognize the difference between statistics and descriptive statistics Define four variable types: nomial, ordinal, interval and ratio Describe the types of descriptive statistics: organize data and summarize data Demonstrate and use commands that help you describe data Python Lecture Notes (general info) Discuss basic probability &amp; statistics overview Identify materials available at https://seeing-theory.brown.edu/ Chapter 1 seems the most relevant at this point Descriptive statistics quantitatively describes or summarizes features of a dataset. Descriptive statistics are used by researchers/analysts to report on populations and samples. Descriptive statistics speed up and simplify comprehension of a group’s characteristics Variable types Nominal: Unordered categorical variables Ordinal: There is an ordering but no implication of equal distance between the different points of the scale. Interval: There are equal differences between successive points on the scale but the position of zero is arbitrary. Ratio: The relative magnitudes of scores and the differences between them matter. The position of zero is fixed. Types of descriptive statistics Organize data: tables and graphs Summarize data: central tendency and variation Tables frequency distributions, relative frequency distributions Graphs bar chart, histogram, boxplot Central tendency mean, median, mode Variation range, interquartile range, variance, standard deviation Python Lecture Notes (useful commands) Import python libraries: import pandas as pd import seaborn as sns Read data into a dataframe (likely review from another section) df = pd.read_csv(“your-filename.csv”) #read a csv file, it better be tidy first! Note: you can read data from other file formats like excel, stata and sas df.method() / description head([n]), tail([n]) / first/last n rows describe() / generate descriptive statistics (for numeric columns only) shape / return a tuple representing the dimensionality of the dataframe info() / prints a dataframe’s summary information, e.g., index dtype and column dtypes, non-null values and memory usage max(), min() / return max/min values for all numeric columns mean(), median() / return mean/median values for all numeric columns std() / standard deviation sample([n]) / returns a random sample of the data frame .groupby() method Splits data into groups based on some criteria you define Then you can calculate statistics (or apply a function) to each group A few performance notes: It’s customary to enact the grouping or splitting of data until it’s needed. Creating the groupby object only verifies that you have passed a valid mapping By default, the group keys are sorted during the groupby operation. You may want to pass sort=False for potential speedup Graphs (Intro to seaborn) Seaborn package is built on matplotlib but provides high level interface for drawing attractive statistical graphics It specifically targets statistical data visualization Reference: https://seaborn.pydata.org/introduction.html import seaborn as sns sns.set(): applies the default default seaborn theme, scaling, and color palette load dataset: e.g., tips = sns.load_dataset(“tips”) where tips is a tidy df relplot() method: designed to visualize many different statistical relationships Example: fmri = sns.load_dataset(“fmri”) where fmri is a tidy df Example: sns.relplot(x=“timepoint,” y=“signal,” col=“region,” hue=“event,” style=“event,” kind=“line,” data=fmri) explain each parameter in kind catplot() method: helps visualize the relationship between one numeric variable and one (or more) categorical variables Example: sns.catplot(x=“day,” y=“total_bill,” hue=“smoker,” kind=“swarm,” data=tips) kind parameter can be changed to: violin, bar, etc. pairplot() method: shows all pairwise relationships and the marginal distributions, optionally conditioned on a categorical variable Example: sns.pairplot(data=iris, hue=“species”) my personal fav when paired w/ .describe() for some initial EDA Live-coding Exercises Try to read the first 10, 20, 50 records of your dataframe? Can you guess how to view the last few records of your dataframe? Find how many records this data frame has How many elements are there? What are the column names? What types of columns we have in this data frame? Give the summary for the numeric columns in the dataset Calculate standard deviation for all numeric columns What are the mean values of the first 50 records in the dataset? Calculate the basic statistics for column XXX (XXX refers to a TBD attribute selected lecture/presentation) Find how many values in column XXX (hint: use the count method) Calculate the average of column XXX How can I create a simple model of my data? Python Learning Objectives Describe clustering and regression Define k-means clustering and linear regression analyses Demonstrate appropriate applications or uses of k-means clustering analysis Demonstrate appropriate applications or uses of linear regression analysis State and specify limitations of both analyses Lecture Notes (K-means Cluster Analysis) Resource: Information to Information Retrieval (https://nlp.stanford.edu/IR-book/information-retrieval-book.html), Chapter 16. Clustering: the process of grouping a set of elemens into classes of similar elements Clustering is also called unsupervised learning, e.g., “learning” from raw data K-means clustering refines goups iteratively where each element belongs to only one group (a nod to flat algorithm approaches w/ hard clustering practices, if we want to expand in later books) Algorithm setup Assumes elementss are real-valued vectors Clusters based on centroids (or mean) of points in a cluster Reassignment of elements to clusters is based on distance to the current cluster centroids. Algorithm Pseudocode Step 0: Select K random elements {s1, s2,…,sK} as seeds. These are your initial K centroids. Step 1: Assign points to closest centroid Step 2: Recompute cluster centroids Step 3: Goto Step 1 A Few FYIs You (designer/coder/developer) must select K K-means always maintains exactly K clusters Clusters may be sensitive to initial seed selection Execution of K-means algorithm tends to converge quickly Live Coding Experience for K-Means (instructor w/ class) - run through https://jakevdp.github.io/PythonDataScienceHandbook/05.11-k-means.html - Note: Expectation Maximization terminology is not explicitly mentioned, should we discuss it? I don’t want to be too term-heavy for novices. Thoughts welcomed. Live Coding Exercises for K-Means (learner on “their own”) - TBD based on at least one of the datasets selected by the group Lecture Notes (Linear Regression) In science, we frequently measure two or more variables on the same individual (case, object, etc). We do this to explore the nature of the relationship among these variables. There are two basic types of relationships. Cause-and-effect relationships and functional relationships. Let’s consider functional relationships. Function: a mathematical relationship enabling us to predict what values of one variable (Y) correspond to given values of another variable (X) Y: is referred to as the dependent variable, the response variable or the predicted variable. X: is referred to as the independent variable, the explanatory variable or the predictor variable. In each case, the statement can be read as; Y is a function of X. Two kinds of explanatory variables: Those we can control Those over which we have little or no control. Example: The time needed to fill a soft drink vending machine Motivating questions What is the association between Y and X? How can changes in Y be explained by changes in X? What are the functional relationships between Y and X? The main formula (ta-da..) Y = b_0 + b_1*X where b_0 = intercept and b_1 = slope b_0 = tells you the impact of X being set to 0 b_1 = tells you the magnitude change between X and X+1 Steps in regression analysis Examine the scatterplot of the data. Does the relationship look linear? Are there points in locations they shouldn’t be? Do we need a transformation? Assuming a linear function looks appropriate, estimate the regression parameters. How do we do this? (Method of Least Squares) Test whether there really is a statistically significant linear relationship. Just because we assumed a linear function it does not follow that the data support this assumption. How do we test this? (F-test for Variances) If there is a significant linear relationship, estimate the response, Y, for the given values of X, and compute the residuals. Examine the residuals for systematic inadequacies in the linear model as fit to the data. Is there evidence that a more complicated relationship (say a polynomial) should be considered; are there problems with the regression assumptions? (Residual analysis). Are there specific data points which do not seem to follow the proposed relationship? (Examined using influence measures). Live Coding Experience for Linear Regression (instructor w/ class) - Seaborn version: https://seaborn.pydata.org/tutorial/regression.html - [Optional] Matplotlib version: https://www.geeksforgeeks.org/linear-regression-python-implementation/ (for those who want more theory) Live Coding Exercises for Linear Regression (learners on “their own”) - TBD based on at least one of the datasets selected by the group Misc. Notes (remove?) formulas frame these as exploratory tools for revealing structure in the data, rather than modelling or inferential tools adding a best fit straight line on a scatterplot (linear regression) understanding what the error bands on a “best fit” straight line mean (linear regression) How can I put people at risk? algorithmic bias Watch this video and discuss w/ class (https://www.youtube.com/watch?v=UG_X_7g63rY) How I’m fighting bias in algorithms by Joy Buolamwini TedTalk Abstract: MIT grad student Joy Buolamwini was working with facial analysis software when she noticed a problem: the software didn’t detect her face – because the people who coded the algorithm hadn’t taught it to identify a broad range of skin tones and facial structures. Now she’s on a mission to fight bias in machine learning, a phenomenon she calls the “coded gaze.” It’s an eye-opening talk about the need for accountability in coding … as algorithms take over more and more aspects of our lives. de-anonymization What isn’t included? statistical tests multiple linear regression anything with “machine learning” in its name 1.4.2.6 Version control What is a version control system? a smarter kind of backup What goes where and why? local vs. remote storage (physically) local vs. remote storage (ethical/privacy issues) How do I track my work locally? diff add commit log How do I view or recover an old version of a file? diff checkout How do I save work remotely? push and pull How do I manage conflicts? merge What isn’t included? forking branching pull requests git reflow –substantive –single-afferent-cycle –ia-ia-rebase-fhtagn … 1.4.2.7 Publishing How do static websites work? URLs servers request/response cycle pages How do I create a simple HTML page? head/body basic elements images links relative vs. absolute paths How can I create a simple website? GitHub pages How can I give pages a standard appearance? layouts How can I avoid writing all those tags? Markdown How can I share values between pages? flat per-site and per-page configuration variable expansion What isn’t included? templating filters inclusions 1.4.2.8 Reproducibility How can I make programs easy to read? coding style linters documentation How can I make programs easy to re-use? Taschuk’s Rules How can I combine explanations, code, and results? notebooks Where does stuff actually live on my computer? directory structure on Windows and Unix absolute vs. relative paths significance of the working directory data on disk vs. data in memory How should I organize my projects? Noble’s Rules RStudio projects How should I keep track of my data? simple manifests What isn’t included? build tools (Make and its kin) continuous integration documentation generators 1.4.2.9 Collaboration What kinds of licenses are there? open vs. closed copyright Who gets to decide what license to use? it depends… What license should I use for my publications? CC-something What license should I use for my software? MIT/BSD vs. GPL What license should I use for my data? CC0 How should I identify myself and my work? DOIs ORCIDs How do I credit someone else’s code? citing packages, citing something from GitHub, giving credit for someone’s answer on StackOverflow… What’s the difference between open and welcoming? evidence for systematic exclusion mechanics of exclusion How can I help create a level playing field? what’s wrong with deficit models allyship, advocacy, and sponsorship Code of Conduct (remove negatives) [curb cuts][curb-cuts] (adding positives for some people helps everyone else too) What isn’t included? how to run a meeting community management mental health assessment of this course "],["intro.html", "Chapter 2 Introduction 2.1 Who are these lessons for? 2.2 What will these lessons teach you? 2.3 What examples will we use? 2.4 What’s the big picture? (#intro-bigpicture}", " Chapter 2 Introduction FIXME: general introduction. 2.1 Who are these lessons for? 2.1.1 Exton Excel Exton taught business at a community college for several years, and now does community management for an event management company. He still teaches Marketing 101 every year to help people with backgrounds like his. Exton uses Excel to keep track of who is registered for webinars, workshops, and training sessions. He doesn’t think of himself as a programmer, but spends hours creating complicated lookup tables to figure out how many webinar attendees turn into community contributors, who answers forum posts most frequently, and so on. Exton knows there are better ways to do what he’s doing, but feels overwhelmed by the blog posts, tweets, and “helpful” recommendations from the company’s engineering team. Exton is a single parent; the one evening a week he spends teaching is the only out-of-work time he can take away from family responsibilities. 2.1.2 Nina Newbie Nina is 18 years old and in the first year of an undergraduate degree in urban planning. She has read lots of gushing articles about data science, and was excited by the prospect of learning how to do it, but dropped her CS 101 course after six weeks because nothing made sense. She is doing better in her intro to statistics (which uses a little bit of R), but still spends most of her time copying, pasting, and swearing. Nina did well in her high school math classes, and built herself a home page with HTML and CSS in a weekend workshop in grade 11. She has accounts on nine different social media site, and attends all of her morning classes online. Nina wants self-paced tutorials with practice exercises, plus forums where she can ask for help. After a few bruising conversations with CS majors, Nina is reluctant to reveal how little she knows about programming: she would rather get a low grade and blame it on partying than let her classmates see that she is floundering. 2.2 What will these lessons teach you? During this course, you will learn how to: Write programs in R that read data, clean it up, perform simple statistical analyses on it. Build visualizations to help you understand your data and communicate your findings. Find and install R packages to help you do these things. Create software that other people can understand and re-run. Track your work in version control using Git and GitHub. Publish your results on a web site using R Markdown and GitHub Pages. Make your data, software, and reports citable using ORCIDs and DOIs, and cite the work of others. Select open source and Creative Commons licenses that allow you and others to share data, software, and reports. Be an active participant in open, inclusive projects. 2.2.1 What do you need to have and know to start? This course assumes that you: Have a laptop that you can install software on, or access to a web-based programming system like [rstudio.cloud][rstudio-cloud]. Know what mean and variance are. Are willing to invest about 30 hours in reading or lectures and another 100 hours doing practice exercises. We have tried to make these lessons accessible to people with visual or motor challenges, but recognize that some parts (particularly data visualization) may still be difficult. We welcome suggestions for improvements. 2.3 What examples will we use? FIXME: introduce running examples 2.4 What’s the big picture? (#intro-bigpicture} We now swim in a sea of data and generate more each day. That data can help us understand the world, but it can also be used to manipulate us and invade our privacy. Learning how to analyze data will help you do the former and guard against the latter. This course is therefore about people, programs, and data. Data can live in three places (FIXME: diagram) In the computer’s memory. It has to be here for the computer to use it, but when a program stops running or the computer is shut down, the contents of memory evaporate. On the computer’s hard drive. This is much larger than memory—terabytes instead of gigabytes—and its contents are organized into files and directories (also called folders). What’s on the hard drive stays there even when programs aren’t running or the computer is switched off. A program must read data from files into memory to work with it, and write data to files to save it permanently. On some other computer on the network. “The cloud” and “the web” are just other people’s computers; if we want to use data that’s on the other side of a URL, we need to download it (i.e., copy it to our hard drive) or read it directly into memory (which is called [streaming][streaming-data]). Programs also live in three places (FIXME: enhanced diagram) In the computer’s memory. A program has to be in memory for the computer to run it. On the computer’s hard drive. A program is a file like any other. Instead of containing text, pixels, or CO2 measurements, it contains instructions. In order for the computer to run it, those instructions have to be copied into memory. (This is part of what your computer is doing when it launches an application.) Your program typically uses other pieces of software called [packages][package] or [libraries][library] that provide common operations like searching in text, changing the colors of pixels, or calculating averages. When your program is loaded into memory, your computer also loads those packages. On some other computer on the network. R and Python both have catalogs of packages that people have written and shared. In order to use one of these, you must [install][install] it on your computer by copying its files from the catalog site to your hard drive. There’s usually more to this than simply copying one file, so R and Python both come with tools to help you find, install, and manage packages. Finally, we come to people (FIXME: enhanced diagram) This course starts by teaching you how to write programs that run on your computer, analyze data that is on your computer or on the web, and use packages written by other people. It will also teach you how to write programs that your collaborators can understand and run. (One of those collaborators is your future self, who will be grateful three months from now that you did the right thing today.) These skills will make you a productive member of a small team, and this course will also explain how to make such teams open and inclusive. The third group of people includes collaborators or reviewers who want to reproduce your work. This course will show you how to publish your results on the web and how to get credit for your work and give it to others. "],["getting-started.html", "Chapter 3 Getting Started with R 3.1 Objectives 3.2 Introduction to RStudio 3.3 Running Code in the Console 3.4 Running Code via Scripts 3.5 Assigning and Recalling Objects 3.6 Viewing installed packages 3.7 Getting Help in RStudio 3.8 Getting Help Online 3.9 Exercises 3.10 Key Points", " Chapter 3 Getting Started with R 3.1 Objectives Compare and contrast the benefits of running code in the console versus a script. Answer a question about a function by looking it up in RStudio. Distinguish between a helpful and less helpful Stack Overflow answer. Identify which RStudio pane will show you a window of a loaded table. As stated in the introduction, our overall goal is to work with people, programs and data. In this section, we will focus on programs and data as we learn how to run R code, as well as how data is stored and accessed on a computer. 3.2 Introduction to RStudio Throughout this book, we’ll be writing programs (or, in verb form, programming) in order to accomplish our goals of working with data on the computer. Programming is one way to make a computer do something for us. Instead of clicking, we’ll mostly be typing; instead of doing what someone else has pre-defined, we’ll have a lot of flexibility to do what we want. Just like using a web browser to access websites, and a program like MS Word to write documents, it’s helpful to have a program on your computer that is designed to make it easy to write and run code. This kind of program is called an “IDE” or Integrated Development Environment. The one we’ll be using in this book for writing R code is called RStudio. RStudio (like many IDEs) has many panes (or panels or boxes), each of which has a different purpose. FIXME: Screenshot or schematic. We’ll take it slowly and introduce the purpose of each pane one at a time. We’ll start with the pane occupying the lefthand side of your screen. 3.3 Running Code in the Console Now that we have our space for writing and running code (our environment) open, it’s time to actually run some code. The first time you open a new installation of RStudio, the pane occupying the entire lefthand side of the screen is called the console. The console is a program that is constantly ready and waiting to accept and run code. The console you see in RStudio is expecting to see R code. Here’s an example you can type or copy in to see how the console works: print(&quot;It was the best of times, it was the worst of times.&quot;) ## [1] &quot;It was the best of times, it was the worst of times.&quot; A function is a set of code that can repeatedly perform a specific task. As you might guess from the name, the R print() function takes in text (indicated by the quotes) and then prints the text back out to the console. R has many built-in functions, each of which accomplishes different things: round(3.1415) ## [1] 3 Sys.Date() ## [1] &quot;2021-05-03&quot; length(&quot;hippo&quot;) ## [1] 1 Part of learning to program is learning some of the base R functions and what they do; in upcoming chapters, we’ll focus on functions that allow you to read in and manipulate data. At some point it may be helpful to write your own functions, which we’ll also cover in another chapter. 3.4 Running Code via Scripts Can you imagine a situation where continuing to type code into the console could become tedious or challenging? Here are some examples: Running the same code many times (you can use the up-arrow to see previous commands - try it! - but if you run many commands, you might end up scrolling a long time. Organizing long sections of code in a meaningful way, and working on subsections separately. Saving the code as a text file that can be stored on the computer’s hard drive and shared with collaborators. Clearly, we need an approach that will allow us to write and run code while keeping a record of our work and allowing us to run (and re-run) parts. The answer to these challenges is to add our R code to a text file called a script. You can create a script in RStudio by using the “File” menu option to select “New file” and then “R Script.” Your R script (a blank text file) should appear on the left side of the screen above the console. Try copying in some of the commands we’ve already run: round(3.1415) ## [1] 3 Sys.Date() ## [1] &quot;2021-05-03&quot; FIXME: Screenshot or animated gif. Now these commands are written in the script, but nothing has happened yet. In order to run the commands from the script (just like we did in the console), we can choose from a variety of run commands. RStudio includes a “Run” button in the script pane. Clicking this button runs the current line of code. You should see both the code and output appear in the console pane on the bottom left. Your cursor will also move to the next line of code. Alternatively, you can use a keyboard shortcut to run code. Hovering your mouse over the run button will show you the shortcut for running code on your computer; this shortcut is typically Ctrl+Enter. You can also try selecting multiple lines of code with your cursor to execute multiple lines simultaneously. Sometimes, when you want to experiment or check something, it can make sense to write and run R code in the console. However, most of the time, you’ll want to write and run your code from a script. Using scripts has the benefit of saving your work while also being able to run the code just like in the console. You and your collaborators can then also easily share and run the code outside of the IDE. We have now told the computer what to do by using R code, and we have run that code in two different ways within our “workbench” - the RSudio IDE. Let’s see what else we can use in this environment to help us. 3.5 Assigning and Recalling Objects Besides running functions that do something (as above), we’ll also want to use R to keep track of information that we’re using throughout our analysis. We save that information by creating an [object][object]) using a name we select, special set of symbols known as the assignment operator (&lt;-), and then the information to save. For example: message &lt;- &quot;It is a far, far better thing that I do, than I have ever done&quot; name_length &lt;- length(&quot;Sydney Carton&quot;) On the top right pane, there’s a tab that says “Environment.” If you click on that, you’ll see the objects you just created listed under “Values.” Objects can represent data of various types - character (collection of letters and numbers encased in quotation marks), numeric (numbers, including decimals) and more. Referencing the name of an object by itself will print the data you assigned to the console. You can also use objects as input to a function: message ## [1] &quot;It is a far, far better thing that I do, than I have ever done&quot; class(message) ## [1] &quot;character&quot; These examples are objects representing small, fairly simple data. Objects can also be much more complex, representing large datasets. Hopefully you can imagine how assigning objects can allow you to work more easily with complex data, which you’ll have a chance to do in the next section. 3.6 Viewing installed packages Functions in R are grouped together into collections of related code called packages. There is a tab in the lower right pane in RStudio called “Packages” that lists all of the packages installed in your version of R. Scrolling down the list, you’ll note that some packages have the box on the left checked. This means the package has been loaded and is available for use. In addition to the built-in packages that come with every installation of R, we have the ability to use packages written by other programmers. One of the most common places to find such code is the Comprehensive R Archive Network, or CRAN. RStudio allows a straightforward way to download and install packages through CRAN. If you click on the “Install” button in the Packages tab, a window will appear allowing you to install from “Repository (CRAN).” In the space below “Packages,” type “tidyverse.” Making sure the box next to “Install dependencies” is checked, click “Install” to download and install this collection of code (which we’ll be using in later sections). If you’d prefer to use code to install packages, rather than the RStudio pane, you could execute the following line of code in your console: install.packages(&quot;tidyverse&quot;) This accomplishes the same task as searching and installing using the Packages pane. We don’t recommend including this code in your script, since you won’t need to install the package every time you run the script. Once a package is installed, you’ll need to ensure it is loaded and all functions within it are recognized by R for use. You can load a package by locating it among installed packages in the Packages pane, and then checking the box to the left of its name. Alternatively, you can perform the same task using code: library(&quot;tidyverse&quot;) It is appropriate to include this code in your script, so any functions from loaded packages are recognized by R and run as expected. 3.7 Getting Help in RStudio There are a number of additional features in RStudio that may be of use, but we’ll discuss them in later sections as the need arises. The remaining tab that will be useful to us now is “Help,” located in the lower right pane. You can search for more information on functions in R by typing the name of the function, such as “round,” into the search box in the Help pane. The text that appears in the window below can sometimes be extensive. You can search within this particular help page using the second search box that reads “Find in Topic.” In this case, type “decimal” to find information about how the function determines the number of decimal points to print in the output. Luckily, R help documentation tends to be formatted very consistently. At the very top, you’ll see the name of the function (“Round,” which in this case represents a collection of related functions) followed by the name of its package inside curly brackets (“{base},” this is important because sometimes different packages have functions with the same names!). Below that, a short title indicates the purpose of the function. “Description” is a more extensive explanation that should help you figure out if the function is appropriate for your use. “Usage” provides information on how the function should be applied through code, and “Arguments” is like a legend for the code described in Usage. The last subheadings, “Details” through “References” and “Examples,” should be self-explanatory. When you’re writing code in your script, you can also access help documentation by prefacing the name of the function with a question mark. Similar to installing packages, searching help documentation is useful when you’re working on writing code, but isn’t particularly helpful to include in your script, so try typing the following code into the console: ?sum After executing that code, you should see the help page for that function appear in the lower right pane. This search method works on functions that are currently loaded. If you would like to perform a global search (e.g., search among all R packages installed on your computer), you can use two question marks instead (remember to enter this in the console): ??filter RStudio also provides helpful pop-up windows that attempt to predict the function name you’re typing. You may see windows that appear as you’re coding, which include short versions of the help documentation. 3.8 Getting Help Online Sometimes you may not be able to find the answers you seek in the documentation available through RStudio. This often happens when you need to do something completely new and you don’t know where to start. In that scenario, there are multiple internet resources that are helpful: blogs Twitter tutorials question pages on Stack Overflow, an open forum that allows community members to ask and answer questions It can be challenging to find the right words to search when you’re troubleshooting something new. Don’t be discouraged, and think about different ways you can apply the terminology you’re learning to make your search terms clearer and more specific. Even when you find information that seems useful, these resources can be overwhelming and confusing. Some things to look for in a Stack Overflow discussion include: Is the question clearly stated and is there example code? If you’re debugging, does the example code look like yours? Answers have upvotes and downvotes. Is there one clear answer that has a lot of upvotes in response to a question? How complex is the answer? While some questions will necessarily have a complicated answer, for many common programming tasks, there should be a solution that only takes a few lines of code. Do you recognize any terms in the solution? If you don’t, are there other terms for which you could search? Conventions: One tool in using help pages (and in reading the rest of the book) will be understanding the conventions that writers use when describing many of the terms introduced in this chapter. For example min() indicates that something is a function, with parentheses to indicate that it is an action with (potentially) input and output. Some other conventions used in this book are: * folder_name/ for a folder * variable_name for variables * column_name for columns 3.9 Exercises Run each of the functions above. Can you explain what each function expects as input, and what kind of output it produces? What would be the pros and cons of using the console versus a script in each situation? Writing a data analysis with multiple steps. Opening a new data set and exploring its dimensions. Checking the value of a variable. After googling “import csv file r,” the two following pages appear in the search results: https://stackoverflow.com/questions/3391880/how-to-get-a-csv-file-into-r http://www.sthda.com/english/wiki/reading-data-from-txt-csv-files-r-base-functions What is useful about these two pages? Do you understand all of the code in the second page? The second page provides many possible options for code to import a csv file. Where would you start in attempting to perform this task? Try reading a csv file: data &lt;- read_csv(&quot;measurements.csv&quot;) Which pane in RStudio will show our new data object? What happens when you click on it? 3.10 Key Points RStudio is an Integrated Development Environment (IDE) for writing R code. You can run R via a script or console. For most scenarios, we write and execute code from a script. IDEs like RStudio have shortcuts and help pages to facilitate writing code. Actions in R are performed by functions and methods. Information in R is stored as objects that are labeled with variables. "],["data-manipulation.html", "Chapter 4 Data Manipulation 4.1 Objectives 4.2 Motivation 4.3 Exploring data in the console 4.4 How can I select subsets of my data? 4.5 How can I calculate new values? 4.6 How can I tell what’s gone wrong in my programs? 4.7 How can I operate on subsets of my data? 4.8 How can I read my own tabular data into R? 4.9 How can I save my results?", " Chapter 4 Data Manipulation 4.1 Objectives 4.2 Motivation To follow along with the code in this chapter you’ll need to download and import the dog_licenses data. Run the following code in the Console: library(tidyverse) dog_licenses &lt;- readr::read_csv(&quot;https://github.com/merely-useful/novice-r/raw/master/data/nyc-dog-licenses.csv.gz&quot;) %&gt;% drop_na(animal_name) This data comes from the [New York City OpenData Portal][nyc-opendata-dogs] where the data is described as: All dog owners residing in NYC are required by law to license their dogs. The data is sourced from the DOHMH Dog Licensing System (https://a816-healthpsi.nyc.gov/DogLicense), where owners can apply for and renew dog licenses. Each record represents a unique dog license that was active during the year, but not necessarily a unique record per dog, since a license that is renewed during the year results in a separate record of an active license period. Each record stands as a unique license period for the dog over the course of the yearlong time frame. Let’s get started by taking a “look” at the data. The RStudio Viewer has an interface much like other spreadsheet programs you might have used. You can use this Viewer to look at the dog_licenses tibble with the View() function: View(dog_licenses) This viewer has some basic data manipulation features: Arrange You can change the order of the rows in the data based on the values in a column by clicking the up/down arrow next to the column name. Filter You can filter to include only rows which have a certain value in a column by first clicking the small funnel icon labelled “Filter,” then typing a desired value in the appropriate column. Arrange and filter are known as data manipulation verbs. Individually, they describe a single simple manipulation of a dataset. It’s surprising how many questions you can answer using just these two basic verbs: How old is the oldest dog in this data? To answer we can arrange the animal_birth_month column in increasing order and see Jack, a Pug from Queens, was born in January 1999 (this license was issued in May 2015, making Jack at least 16 at the time). You’ll notice that there are other dogs with this same birthday. What range of license issue dates are in this data? Arrange license_issued_date once in increasing order and once in decreasing order, to find the issue dates range from 12th September 2015 to 31st December 2016. How many dogs licenses belong to dogs named Fido? Filter the animal_name column with Fido, and see “Showing … of 12 entries” - so 12! and many more… While these verbs are powerful in their own right, their real power comes from combining them. For example, we can answer the more complicated question “Which dog named Fido is the oldest?” by first filtering then arranging. The Viewer in RStudio, however, has two huge limitations: It’s a point and click interface. This means to repeat the same operation again you need to remember exactly the steps of point, clicking and typing you performed to get to your answer. Consequently, it’s hard to share those steps unambiguously with someone else, and it’s hard to save your results for future. The manipulation verbs in the viewer are limited. There is no way to rearrange the columns, add new variables or calculate summaries like counts or averages. You’ll start this chapter by overcoming this first limitation. You won’t use the Viewer to arrange and filter, you’ll learn to write code to do the same operations. Then you’ll increase your vocabulary of data manipulation verbs to include: selecting variables, adding variables, summarizing rows, and performing these operations on subsets of the data. Combining these verbs you’ll be able to answers questions like: How long are licences issued for? What are the most popular breeds? What names are most popular for licensed dogs in New York? Does this vary geographically? When are dogs born? FIXME: update these question to reflect things that are actually done in this and later chapters. To master data manipulation you need to master two pieces: How to describe the action you want with the data manipulation verbs individually. This is a language specific skill - in this chapter, you’ll use the functions in the dplyr package. Identifying which verbs, and in which order to apply them, to answer a question of interest. This skill will translate across all technologies, but it takes a little longer to master. 4.2.1 Exercise: Point and click data manipulation Using the RStudio Viewer answer the following questions: How many dog licenses belong to dogs named “Queen” that live in “Queens?” 4.3 Exploring data in the console Let’s take a look at the data in the console: dog_licenses ## # A tibble: 118,542 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 533 BONITA F 2013-05-01 Unknown Queens ## 2 548 ROCKY M 2014-05-01 Labrador Retr… Queens ## 3 622 BULLY M 2010-07-01 American Pit … Queens ## 4 633 COCO M 2005-02-01 Labrador Retr… Queens ## 5 655 SKI F 2012-09-01 American Pit … Queens ## 6 872 CHASE M 2013-11-01 Shih Tzu Queens ## 7 874 CHEWY M 2014-09-01 Shih Tzu Queens ## 8 875 CHASE M 2008-08-01 Labrador Retr… Queens ## 9 893 MILEY F 2008-07-01 Boxer Queens ## 10 919 KENZI F 2010-05-01 Schnauzer, Mi… Queens ## # … with 118,532 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; Notice that in contrast to the Viewer you only see the first 10 rows of the dataset, and just the first few columns. The number of columns you see depends on the width of your console, so you may see more or fewer than displayed here. You should also note some of the contents of the columns have been abbreviated. The … at the end of some values in breed_name indicates these values have been truncated for display purposes. You’ll be using the dplyr package for data manipulation. Since it is part of the tidyverse, you’ll need to load the tidyverse package to begin: library(tidyverse) 4.3.1 Re-arranging rows You can reorder rows of data with the dplyr function arrange(). The arrange function takes a tibble as its first argument and column names as the remaining arguments. The result will have the rows ordered in increasing value of the specified column. For example, to find the licenses belonging to the oldest dogs we arrange dog_licenses using the animal_birth_month column: arrange(dog_licenses, animal_birth_month) ## # A tibble: 118,542 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 15568 JACK M 1999-01-01 Pug Queens ## 2 23695 KATTY F 1999-01-01 Chihuahua Queens ## 3 101309 TOMMY M 1999-01-01 Unknown Queens ## 4 1598 SARAH F 1999-01-01 West High Whi… Queens ## 5 8628 DOMINO M 1999-01-01 Labrador Retr… Queens ## 6 15733 BRINKS M 1999-01-01 Yorkshire Ter… Queens ## 7 30419 LUCKY M 1999-01-01 Unknown Queens ## 8 31348 MAGGIE F 1999-01-01 German Shephe… Queens ## 9 34685 COOKIE M 1999-01-01 Pomeranian Queens ## 10 37194 DARCY F 1999-01-01 Cocker Spaniel Queens ## # … with 118,532 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; You’ll see Jack the Pug that lives in Queens, just like you did in the Viewer. To arrange the rows by decreasing value, you need to wrap the column name in desc() (short for descending order). For instance to find the youngest dogs: arrange(dog_licenses, desc(animal_birth_month)) ## # A tibble: 118,542 x 15 ## row_number animal_name animal_gender animal_birth_mo… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 120352 MARLEY M 2016-12-01 Cocker Spani… Manhatt… ## 2 121981 MR. M 2016-12-01 Chihuahua Cr… Brooklyn ## 3 120501 RORY M 2016-12-01 Unknown Brooklyn ## 4 122028 TAQUITO M 2016-12-01 Papillon Staten … ## 5 115820 REX M 2016-11-01 Maltese Queens ## 6 121727 CHANDERBALLI M 2016-11-01 Havanese Queens ## 7 115777 ANGEL F 2016-11-01 Poodle, Mini… Queens ## 8 118175 MASON M 2016-11-01 American Sta… Queens ## 9 121601 TEDDY M 2016-11-01 Havanese Brooklyn ## 10 120995 LOLA F 2016-11-01 Morkie Staten … ## # … with 118,532 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; As another example, to find the earliest issue date we can order by increasing license_issued_date: arrange(dog_licenses, license_issued_date) ## # A tibble: 118,542 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 QUEEN F 2013-04-01 Akita Crossbr… Manhat… ## 2 2 CHEWBACCA F 2012-06-01 Labrador Retr… Manhat… ## 3 3 IAN M 2006-01-01 Unknown Manhat… ## 4 7 LOLA F 2009-06-01 Maltese Manhat… ## 5 4 PAIGE F 2014-07-01 American Pit … Manhat… ## 6 5 BUDDY M 2008-04-01 Unknown Manhat… ## 7 8 YOGI M 2010-09-01 Boxer Bronx ## 8 10 MUNECA F 2013-05-01 Beagle Brookl… ## 9 27 BESS F 2010-09-01 Beagle Brookl… ## 10 26 BIGS M 2004-12-01 American Pit … Brookl… ## # … with 118,532 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; The first row is the record with the earliest issue date, but we can’t actually see that date because the column license_issued_date isn’t being displayed due to space. One solution is to extract only the columns we are interested in, a manipulation known as selecting columns. 4.3.2 Exercise: Arranging character strings Use arrange() to order the dog licenses by animal_name in increasing order. What does this tell you about the way R treats punctuation and numbers when dealing with alphabetical order? 4.4 How can I select subsets of my data? Two verbs are used to subset data: select() to select columns filter() to select rows You’ll learn about these two functions in this section, along with learning about a way to chain together multiple operations on a dataset. 4.4.1 Selecting columns The select() function in dplyr is used to extract some subset of columns (but keep all the rows) from a tibble. Just like arrange(), it takes a tibble as its first argument and column names as the remaining arguments. For example, to keep only the animal_name column: select(dog_licenses, animal_name) ## # A tibble: 118,542 x 1 ## animal_name ## &lt;chr&gt; ## 1 BONITA ## 2 ROCKY ## 3 BULLY ## 4 COCO ## 5 SKI ## 6 CHASE ## 7 CHEWY ## 8 CHASE ## 9 MILEY ## 10 KENZI ## # … with 118,532 more rows You can provide additional column names as arguments to keep additional specified columns, for example to keep animal_name and breed_name: select(dog_licenses, animal_name, breed_name) ## # A tibble: 118,542 x 2 ## animal_name breed_name ## &lt;chr&gt; &lt;chr&gt; ## 1 BONITA Unknown ## 2 ROCKY Labrador Retriever Crossbreed ## 3 BULLY American Pit Bull Terrier/Pit Bull ## 4 COCO Labrador Retriever ## 5 SKI American Pit Bull Terrier/Pit Bull ## 6 CHASE Shih Tzu ## 7 CHEWY Shih Tzu ## 8 CHASE Labrador Retriever ## 9 MILEY Boxer ## 10 KENZI Schnauzer, Miniature ## # … with 118,532 more rows To return to finding the earliest issue date, you need to first arrange by increasing license_issued_date and then select the license_issued_date column. One approach is to store the result of the arrange step, dog_by_date &lt;- arrange(dog_licenses, license_issued_date) Then apply the select step to this object: select(dog_by_date, license_issued_date) ## # A tibble: 118,542 x 1 ## license_issued_date ## &lt;date&gt; ## 1 2014-09-12 ## 2 2014-09-12 ## 3 2014-09-12 ## 4 2014-09-12 ## 5 2014-09-12 ## 6 2014-09-12 ## 7 2014-09-12 ## 8 2014-09-13 ## 9 2014-09-13 ## 10 2014-09-13 ## # … with 118,532 more rows There are lots of shortcuts you can use with select() to avoid having to type out all the variables you want to keep. For example, you can ask for all the columns that start with a certain string: select(dog_licenses, starts_with(&quot;Animal&quot;)) ## # A tibble: 118,542 x 3 ## animal_name animal_gender animal_birth_month ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 BONITA F 2013-05-01 ## 2 ROCKY M 2014-05-01 ## 3 BULLY M 2010-07-01 ## 4 COCO M 2005-02-01 ## 5 SKI F 2012-09-01 ## 6 CHASE M 2013-11-01 ## 7 CHEWY M 2014-09-01 ## 8 CHASE M 2008-08-01 ## 9 MILEY F 2008-07-01 ## 10 KENZI F 2010-05-01 ## # … with 118,532 more rows Take a look in the [“Useful functions” section of the select() help page][select-docs] for a complete list: ?dplyr::select 4.4.2 Exercise: Find the latest license issue date Combine arrange() and select() to confirm the last issue date in this dataset is 31st December 2016. 4.4.3 Combining operations with the pipe %&gt;% You’ve seen you can combine data manipulation steps to do more complicated tasks, but so far you’ve done so by saving an intermediate object, in our previous example the object dog_by_date: dog_by_date &lt;- arrange(dog_licenses, license_issued_date) select(dog_by_date, license_issued_date) The pipe, %&gt;%, is an operator that allows you to chain together operations without intermediate objects and maintain readability. The name, “pipe,” comes from the plumbing kind of pipe, not the smoking kind, and references the idea of objects flowing out of one function and into another. Let’s just look at the first step in our manipulation: arrange(dog_licenses, license_issued_date) With the pipe this can be rewritten as: dog_licenses %&gt;% arrange(license_issued_date) The pipe takes the object on the left hand side and passes it as the first argument to the function on the right hand side. So, here the dog_licenses dataset is passed to the first argument of arrange(). Inside arrange() we can then list any additional arguments as we normally would. The pipe works very nicely with the data manipulation verbs because every verb expects a tibble as its first argument and returns a tibble. This means the result of one operation is easily piped into the next operation, allowing you to chain together multiple steps. For instance, piping the result of the arrange step above into the select() function: dog_licenses %&gt;% arrange(license_issued_date) %&gt;% select(license_issued_date) When you see the pipe, read it as “and then.” So, the above code would be read: Take the dog_licenses data, and then arrange the rows by the license_issued_date, and then select the column license_issued_date. The result is code that matches very closely how we might describe the steps we performed in natural language. It’s so natural that for the remainder of the chapter we’ll use the pipe when combining data manipulation steps. 4.4.4 Exercise: Reading aloud Read the following code aloud to your neighbor (or cat, dog, or [rubber duck][rubber-duck-debugging]). Remember to pronounce %&gt;% as “and then.” dog_licenses %&gt;% arrange(license_issued_date) %&gt;% select(license_expired_date) What question might it answer? 4.4.5 Exercise: Using the pipe Re-write this snippet of code to use the pipe: select(dog_licenses, animal_name, breed_name) Use the pipe to re-write this snippet of code to avoid the intermediate variable: name_and_breed &lt;- select(dog_licenses, animal_name, breed_name) arrange(name_and_breed, breed_name) 4.4.6 Filtering to keep a subset of rows The function to filter rows of a tibble is filter(). Like arrange() and select(), its first argument is a tibble. The remaining arguments describe which rows to keep. The rows to keep are specified with a logical expression - something that is either TRUE or FALSE. The rows where this expression is TRUE will be returned. One of the simplest kinds of logical expression is a test for equality with the == operator. For example, to keep the rows where animal_name is BRUNO you could do: dog_licenses %&gt;% filter(animal_name == &quot;BRUNO&quot;) ## # A tibble: 272 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 12001 BRUNO M 2010-05-01 American Pit … Queens ## 2 27228 BRUNO M 2013-07-01 Jack Russell … Queens ## 3 68192 BRUNO M 2002-01-01 Shih Tzu Queens ## 4 70175 BRUNO M 2015-12-01 Chihuahua Cro… Queens ## 5 120562 BRUNO M 2016-05-01 Labrador Retr… Queens ## 6 3915 BRUNO M 2014-03-01 Doberman Pins… Queens ## 7 9614 BRUNO M 2014-12-01 Boxer Queens ## 8 15606 BRUNO M 2015-02-01 French Bulldog Queens ## 9 32742 BRUNO M 2014-03-01 Maltipoo Queens ## 10 34299 BRUNO M 2003-01-01 Unknown Queens ## # … with 262 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; You could read this code aloud as: Take the dog_licenses data, and then filter for only rows when animal_name is equal to “BRUNO” The logical expression, animal_name == \"BRUNO\", will be TRUE when the value of the animal_name column is exactly equal to the character string \"BRUNO\" - any differences in characters, case, or whitespace will result in FALSE. Above, each value within a column was compared against the same fixed string (\"BRUNO\"). You can also compare the values from two columns against each other by including a column name on each side of the == sign. In programming terms this is known as element-wise comparison. For example, license_issued_date == animal_birth_month will return TRUE for a row only if for that row the date the license was issued is the exact same date as the birth month for the dog. If you take a look: dog_licenses %&gt;% filter(license_issued_date == animal_birth_month) ## # A tibble: 0 x 15 ## # … with 15 variables: row_number &lt;dbl&gt;, animal_name &lt;chr&gt;, ## # animal_gender &lt;chr&gt;, animal_birth_month &lt;date&gt;, breed_name &lt;chr&gt;, ## # borough &lt;chr&gt;, zip_code &lt;dbl&gt;, community_district &lt;dbl&gt;, ## # census_tract_2010 &lt;dbl&gt;, neighborhood_tabulation_area &lt;chr&gt;, ## # city_council_district &lt;dbl&gt;, congressional_district &lt;dbl&gt;, ## # state_senatorial_district &lt;dbl&gt;, license_issued_date &lt;date&gt;, ## # license_expired_date &lt;date&gt; There is no output (apart from the column names), which means that no rows satisfy this criteria. Remember that a string is surrounded by quotes while a column name is not. When you are reading code, look for the quotes to figure out if the comparison is to a string, or (by the absence of quotes) to the strings within a column. Use the same strategy to figure out where the quotes should be in your own code, but beware: misplacing quotes often won’t result in an error, but instead a result that you weren’t expecting. For example, I might be interested in the licenses issued to male dogs and try: dog_licenses %&gt;% filter(&quot;animal_gender&quot; == &quot;M&quot;) ## # A tibble: 0 x 15 ## # … with 15 variables: row_number &lt;dbl&gt;, animal_name &lt;chr&gt;, ## # animal_gender &lt;chr&gt;, animal_birth_month &lt;date&gt;, breed_name &lt;chr&gt;, ## # borough &lt;chr&gt;, zip_code &lt;dbl&gt;, community_district &lt;dbl&gt;, ## # census_tract_2010 &lt;dbl&gt;, neighborhood_tabulation_area &lt;chr&gt;, ## # city_council_district &lt;dbl&gt;, congressional_district &lt;dbl&gt;, ## # state_senatorial_district &lt;dbl&gt;, license_issued_date &lt;date&gt;, ## # license_expired_date &lt;date&gt; The result has zero rows, which would suggest there are no such licenses, but in fact this is the answer to a different question. Can you see what is wrong with the code? By surrounding animal_gender in quotes, R has interpreted the comparison as: is the string \"animal_gender\" equal to the string \"M\"?. The answer is FALSE, and no rows are returned. I actually wanted to compare the animal_gender column to the string \"M\", so animal_gender should have no quotes around it: dog_licenses %&gt;% filter(animal_gender == &quot;M&quot;) ## # A tibble: 64,770 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 548 ROCKY M 2014-05-01 Labrador Retr… Queens ## 2 622 BULLY M 2010-07-01 American Pit … Queens ## 3 633 COCO M 2005-02-01 Labrador Retr… Queens ## 4 872 CHASE M 2013-11-01 Shih Tzu Queens ## 5 874 CHEWY M 2014-09-01 Shih Tzu Queens ## 6 875 CHASE M 2008-08-01 Labrador Retr… Queens ## 7 976 APOLLO M 2014-10-01 American Pit … Queens ## 8 1297 JERRY M 2009-06-01 Labrador Retr… Queens ## 9 2133 SIMON M 2010-12-01 Havanese Queens ## 10 2289 BUDDY M 2012-06-01 Labrador Retr… Queens ## # … with 64,760 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; The operator, == (you can read as “is equal to,” or simply “equals”), is a specific kind of comparison. Other comparisons include: Operator Meaning &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to != not equal to 4.4.7 Exercise: Enterprising dogs Are there any dogs called “Spock,” “Picard,” or “Janeway?” These are Star Trek characters. Can you find any dogs with the same name as your favorite character from a book, TV show, or movie? 4.4.8 Exercise: Expired Licenses This code creates a variable that contains the date for the start of the year 2016: start_of_2016 &lt;- as.Date(&quot;2016-01-01&quot;) Use filter() with this variable to find: The dog licenses that were issued before 2016 The dog licenses that expire before 2016 4.4.9 More complicated expressions Logical expressions can be combined with logical operators to construct more complicated expressions. For example, the AND operator, &amp;, returns TRUE only if the expressions on both sides of it are TRUE. For example, you’ve seen, you can find the licenses to dogs called \"BRUNO\": dog_licenses %&gt;% filter(animal_name == &quot;BRUNO&quot;) ## # A tibble: 272 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 12001 BRUNO M 2010-05-01 American Pit … Queens ## 2 27228 BRUNO M 2013-07-01 Jack Russell … Queens ## 3 68192 BRUNO M 2002-01-01 Shih Tzu Queens ## 4 70175 BRUNO M 2015-12-01 Chihuahua Cro… Queens ## 5 120562 BRUNO M 2016-05-01 Labrador Retr… Queens ## 6 3915 BRUNO M 2014-03-01 Doberman Pins… Queens ## 7 9614 BRUNO M 2014-12-01 Boxer Queens ## 8 15606 BRUNO M 2015-02-01 French Bulldog Queens ## 9 32742 BRUNO M 2014-03-01 Maltipoo Queens ## 10 34299 BRUNO M 2003-01-01 Unknown Queens ## # … with 262 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; And you could find the dog licenses issued to dogs that live in Brooklyn: dog_licenses %&gt;% filter(borough == &quot;Brooklyn&quot;) ## # A tibble: 29,334 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2895 FUDGE M 2014-07-01 American Pit … Brookl… ## 2 4057 STAR F 2011-01-01 Poodle Brookl… ## 3 74463 MUNECA F 2011-09-01 Chihuahua Cro… Brookl… ## 4 76232 KATTY F 2002-06-01 Chihuahua Brookl… ## 5 85113 SHADOW M 2015-03-01 American Pit … Brookl… ## 6 85997 SPARKIE M 2013-08-01 Maltese Cross… Brookl… ## 7 92451 SNOW M 2014-07-01 Maltese Brookl… ## 8 104256 BELLA F 2016-07-01 Maltese Brookl… ## 9 10389 SPARKLE F 2006-01-01 Schnauzer, St… Brookl… ## 10 82492 UNKNOWN F 2015-11-01 Pomeranian Brookl… ## # … with 29,324 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; If you want to find the licenses that are to dogs named Bruno in Brooklyn, you could combine the two logical statements with &amp;: dog_licenses %&gt;% filter((animal_name == &quot;BRUNO&quot;) &amp; (borough == &quot;Brooklyn&quot;)) ## # A tibble: 55 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 8496 BRUNO M 2005-04-01 American Pit … Brookl… ## 2 65466 BRUNO M 2012-11-01 Golden Retrie… Brookl… ## 3 115999 BRUNO M 2009-01-01 Pug Brookl… ## 4 118963 BRUNO M 2005-01-01 Unknown Brookl… ## 5 10505 BRUNO M 2006-04-01 Bull Dog, Eng… Brookl… ## 6 14444 BRUNO M 2007-01-01 Cocker Spaniel Brookl… ## 7 14690 BRUNO M 2014-04-01 Shih Tzu Brookl… ## 8 47454 BRUNO M 2011-06-01 Pug Brookl… ## 9 58918 BRUNO M 2006-04-01 Bull Dog, Eng… Brookl… ## 10 105964 BRUNO M 2016-04-01 Bull Dog, Fre… Brookl… ## # … with 45 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; The parentheses around each logical expression are optional, but can help visually to group the components to &amp;, especially if those logical expressions get more complicated. If you want to create an “or” type expression, like “licenses to dogs named BRUNO or dogs named BRUCE,” you need to combine two comparisons with the OR operator, |. dog_licenses %&gt;% filter((animal_name == &quot;BRUNO&quot;) | (animal_name == &quot;BRUCE&quot;)) If you find yourself combining lots of comparisons on the same column with |, like dogs named BRUNO, BRUCE or BRADY: dog_licenses %&gt;% filter((animal_name == &quot;BRUNO&quot;) | (animal_name == &quot;BRUCE&quot;) | (animal_name == &quot;BRADY&quot;)) You can save a lot of typing with %in%: dog_licenses %&gt;% filter(animal_name %in% c(&quot;BRUNO&quot;, &quot;BRUCE&quot;, &quot;BRADY&quot;)) On the right hand side of %in% the function c(), combines many single values into a vector. %in% will return TRUE for an element of the left hand side if it is contained in the vector on the right hand side. 4.4.10 Exercise: Expired Licenses This code creates two variables that contain the dates for the start and end of the year 2016: start_of_2016 &lt;- as.Date(&quot;2016-01-01&quot;) endt_of_2016 &lt;- as.Date(&quot;2016-12-31&quot;) Use filter() with these variables to find the dog licenses that expire during 2016. 4.5 How can I calculate new values? So far, you’ve been manipulating the columns that already exist in a dataset, but what if you want to add new ones? The function mutate() handles this kind of operation. To see how this works let’s start with a logical expression: animal_name == \"CHASE\". If you used this with filter(), you would get all the rows back where the license was issued to a dog named CHASE. Let’s say instead of subsetting the data, you want to add a column called called_chase that contained the TRUE and FALSE result. You might do this for example, if you are interested in comparing the two groups of dogs, rather than just keeping one of them. With mutate() after passing in the data, you pass named arguments, where the name is the name you desire for the new column, and its value is the way to calculate it: dog_licenses %&gt;% mutate(called_chase = animal_name == &quot;CHASE&quot;) %&gt;% select(animal_name, called_chase) ## # A tibble: 118,542 x 2 ## animal_name called_chase ## &lt;chr&gt; &lt;lgl&gt; ## 1 BONITA FALSE ## 2 ROCKY FALSE ## 3 BULLY FALSE ## 4 COCO FALSE ## 5 SKI FALSE ## 6 CHASE TRUE ## 7 CHEWY FALSE ## 8 CHASE TRUE ## 9 MILEY FALSE ## 10 KENZI FALSE ## # … with 118,532 more rows Take dog_licences, and then, mutate to add a column called called_chase which is the result of testing whether animal_name is exactly \"CHASE\", and then, select the columns animal_name and called_chase. The select statement isn’t crucial to the calculation here, but it does help me draw your attention to the columns that were involved in this step. This can be a useful intermediate step in filtering, since it gives you a chance to examine the logical statement before using it to filter: dog_licenses %&gt;% mutate(called_chase = animal_name == &quot;CHASE&quot;) %&gt;% filter(called_chase) ## # A tibble: 126 x 16 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 872 CHASE M 2013-11-01 Shih Tzu Queens ## 2 875 CHASE M 2008-08-01 Labrador Retr… Queens ## 3 32652 CHASE M 2013-09-01 Yorkshire Ter… Queens ## 4 42125 CHASE M 2015-08-01 Chihuahua Queens ## 5 109847 CHASE M 2013-04-01 Terrier mix Queens ## 6 114557 CHASE M 2009-07-01 Siberian Husky Queens ## 7 33434 CHASE M 2014-08-01 Schnauzer, St… Queens ## 8 45142 CHASE M 2005-01-01 Unknown Queens ## 9 2528 CHASE M 2011-10-01 Lhasa Apso Queens ## 10 3426 CHASE M 2014-03-01 Yorkshire Ter… Queens ## # … with 116 more rows, and 10 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt;, called_chase &lt;lgl&gt; Take a closer look at the argument to mutate: called_chase = animal_name == &quot;CHASE&quot; On the left of the = is the argument name, called_chase. This is a name you choose - it should be descriptive and follow good style. On the right of the = is an expression that must either return as many values as there are rows, or a single value. Here, the logical expression involves the column animal_name so it returns as many values as there are rows. If you would prefer the values to be something other than TRUE or FALSE, instead maybe you want them to be something like \"called chase\" or \"not called chase\", we would need to use the ifelse(). A call to ifelse() takes the form: ifelse(test, yes, no) Where test is a logical expression, yes the value for the elements that return TRUE, and no the value for the elements that return FALSE (Figure 4.1). (Both yes and no could be other column names, in which case the corresponding element of yes would be returned for TRUE elements). dog_licenses %&gt;% mutate( called_chase = ifelse(animal_name == &quot;CHASE&quot;, &quot;called chase&quot;, &quot;not called chase&quot;) ) %&gt;% select(animal_name, called_chase) ## # A tibble: 118,542 x 2 ## animal_name called_chase ## &lt;chr&gt; &lt;chr&gt; ## 1 BONITA not called chase ## 2 ROCKY not called chase ## 3 BULLY not called chase ## 4 COCO not called chase ## 5 SKI not called chase ## 6 CHASE called chase ## 7 CHEWY not called chase ## 8 CHASE called chase ## 9 MILEY not called chase ## 10 KENZI not called chase ## # … with 118,532 more rows Figure 4.1: Schematic of ifelse(). You can perform multiple mutate steps at once by passing more arguments to mutate(), so an alternative way of writing the above code (with more keystrokes, but with lines that are shorter) would be: dog_licenses %&gt;% mutate( is_chase = animal_name == &quot;CHASE&quot;, called_chase = ifelse(is_chase, &quot;called chase&quot;, &quot;not called chase&quot;) ) %&gt;% select(animal_name, is_chase, called_chase) ## # A tibble: 118,542 x 3 ## animal_name is_chase called_chase ## &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 BONITA FALSE not called chase ## 2 ROCKY FALSE not called chase ## 3 BULLY FALSE not called chase ## 4 COCO FALSE not called chase ## 5 SKI FALSE not called chase ## 6 CHASE TRUE called chase ## 7 CHEWY FALSE not called chase ## 8 CHASE TRUE called chase ## 9 MILEY FALSE not called chase ## 10 KENZI FALSE not called chase ## # … with 118,532 more rows Notice that the computation for the called_chase column refers to the is_chase column. The arguments to mutate are computed in order, so columns created later in the same mutate() can refer to columns created earlier. Arithmetic is another common operation that returns as many elements as there are rows. For instance we could see how long licenses are issued for: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% select(license_duration) ## # A tibble: 118,542 x 1 ## license_duration ## &lt;drtn&gt; ## 1 1118 days ## 2 1826 days ## 3 697 days ## 4 1096 days ## 5 1826 days ## 6 731 days ## 7 731 days ## 8 1097 days ## 9 421 days ## 10 402 days ## # … with 118,532 more rows The output shows us licenses aren’t issued for a standard time period. In these first rows, there are some licenses issued for a whole number of years: 2 (731 days), 3 (1097 days) and 5 (1826 days). However, others seem to be for fractions of years like 421 days. You can find other functions that are useful in combination with mutate() in the [“Useful functions” section of the mutate() documentation][mutate-useful]. You can use mutate() with operations that give one number based on all the rows: dog_licenses %&gt;% mutate( license_duration = license_expired_date - license_issued_date, avg_duration = mean(license_duration)) %&gt;% select(license_duration, avg_duration) ## # A tibble: 118,542 x 2 ## license_duration avg_duration ## &lt;drtn&gt; &lt;drtn&gt; ## 1 1118 days 467.321 days ## 2 1826 days 467.321 days ## 3 697 days 467.321 days ## 4 1096 days 467.321 days ## 5 1826 days 467.321 days ## 6 731 days 467.321 days ## 7 731 days 467.321 days ## 8 1097 days 467.321 days ## 9 421 days 467.321 days ## 10 402 days 467.321 days ## # … with 118,532 more rows You’ll get back the original number of rows, but the single value will be repeated in all of them - on average licenses are issued for 467.321 days. You’ll see a different verb, summarise() that collapses many rows into one later in this chapter. 4.5.1 Exercise: Ages of dogs Use mutate() to add a column age_at_issue that contains the dogs approximate age on the day the license was issued. 4.5.2 Exercise: Unknown breeds Use mutate() along with ifelse() to create a column breed that takes values \"unknown\" if breed_name is \"unknown\" and \"known\" otherwise. Extra challenge Can you figure out if the licenses issued to unknown breed dogs are of longer or shorter duration on average than known breed dogs? 4.5.3 Exercise: Name length The function str_length() in the stringr package finds the length of character strings. Replace the ___ in following code to add a column called name_length that contains the length of the dog’s name: dog_licenses %&gt;% ___(___ = stringr::str_length(animal_name)) Now add an arrange() step to find the licenses issued to dogs with the longest names? 4.6 How can I tell what’s gone wrong in my programs? FIXME: The errors shown in the markdown are way more informative than those in the Console. Try to get the error displaying in the book like they do for someone in the console? Let me share an interaction my (CVW’s) husband had at a Trader Joes (a small specialized supermarket) soon after we arrived in the USA from New Zealand. Josh: “Do you sell bat-trees?” Store-person: “What?” Josh: “Do you sell bat-trees?” Store person: “Huh? Bat…trees?” Josh: \"Do you sell bat-er-ries? Store-person: “Oh…you mean batteries! No. We don’t sell batteries.” This is a pretty accurate analogy for what it feels like when you are learning R. You know what you want, but you have to ask for it in a way R understands. When R doesn’t understand you, or when R can’t give you what you want, you’ll get an error. You’ll know when you get one in R because the only output you see will start with Error. buy_batteries(store = &quot;Trader Joes&quot;) ## Error in buy_batteries(store = &quot;Trader Joes&quot;): could not find function &quot;buy_batteries&quot; It’s also a good illustration of the two kinds of problems that occur: syntax errors and runtime errors. Syntax errors are like the “What? Huh?” moments. R doesn’t understand what you are asking it to do, because something about the way you are asking doesn’t conform to what R expects and it will not even try to run your code. Runtime errors are more like the “No, I can’t help you” moments. R understands what you are asking and runs your code, but during the run something goes wrong and R has to stop running the code. You generally want to make sure you’ve ruled out syntax errors before assuming it’s a runtime error. Unfortunately, R doesn’t distinguish these two types of error in its output, so we’ll discuss some of the most common examples in the following sections. This analogy is also a reminder that sometimes you’ll have to repeat yourself. With R, giving the exact same instruction should always result in the exact same error, but it’s not uncommon, even for longtime R users, to run and edit a line of code multiple times before it runs without error. There is one flaw in this analogy: R isn’t a real person. So, if you need to vent your frustration by cursing it, insulting its parentage or storming off, it’s fine, no one’s feelings will be hurt. Of course, it won’t change R’s response… 4.6.1 Common syntax errors Syntax errors occur when your code can’t be broken into its component pieces by R. For example, R expects the arguments to a function to start after the opening parenthesis ((), be separated by a comma (,) and finish at the closing parenthesis ()). When R sees this code: filter(dog_licenses breed_name == &quot;Finnish Lapphund&quot;) ## Error: &lt;text&gt;:1:21: unexpected symbol ## 1: filter(dog_licenses breed_name ## ^ The missing comma means R can’t figure out where the first argument to filter() ends: is it after dog_licenses, after breed_name, or after ==? Take a closer look at the error message. Error messages always begin with Error, then optionally the name of the function that returned an error (not in this example), followed by a :, and some description of the error that occurred. The message unexpected symbol is one common kind of syntax error - in this case R encountered some code where it was expecting a comma or closing parenthesis. We can fix it by putting in the missing comma: filter(dog_licenses, breed_name == &quot;Finnish Lapphund&quot;) ## # A tibble: 1 x 15 ## row_number animal_name animal_gender animal_birth_month breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 118408 FREDDIE M 2011-11-01 Finnish Lapp… Manhatt… ## # … with 9 more variables: zip_code &lt;dbl&gt;, community_district &lt;dbl&gt;, ## # census_tract_2010 &lt;dbl&gt;, neighborhood_tabulation_area &lt;chr&gt;, ## # city_council_district &lt;dbl&gt;, congressional_district &lt;dbl&gt;, ## # state_senatorial_district &lt;dbl&gt;, license_issued_date &lt;date&gt;, ## # license_expired_date &lt;date&gt; Syntax errors are usually the result of typos. Some things to keep an eye out for: If you are modelling your code on an example, pay very close attention to the punctuation: commas ,, parenthesis (, ), brackets, [, ], and quotes \", '. Every opening parenthesis, bracket, or quote needs a matching closing one, and they must be closed in the reverse order they were opened. New lines don’t matter if they happen between arguments, or after pipe operators, but they can be problematic in other locations. R ignores other whitespace (spaces or tabs) unless it’s inside a character string (i.e. inside quotes), so different spacing shouldn’t be the cause of an error, but it is a good idea to follow good style for spacing. FIXME: link to style guide section. 4.6.2 Exercise: Syntax errors Fix these syntax errors. dog_licenses %&gt;% arrange(desc(license_expired_date))) ## Error: &lt;text&gt;:2:38: unexpected &#39;)&#39; ## 1: dog_licenses %&gt;% ## 2: arrange(desc(license_expired_date))) ## ^ dog_licenses %&gt;% mutate( month_born = lubridate::month(animal_birth_month) year_born = lubridate::year(animal_birth_month)) ## Error: &lt;text&gt;:4:5: unexpected symbol ## 3: month_born = lubridate::month(animal_birth_month) ## 4: year_born ## ^ dog_licenses %&gt;% filter(animal_name == &quot;BRUNO) ## Error: &lt;text&gt;:2:25: unexpected INCOMPLETE_STRING ## 1: dog_licenses %&gt;% ## 2: filter(animal_name == &quot;BRUNO) ## ^ (If you run this code in the Console, you might not get an error, but you should see a + on a new line, a signal that R is waiting for more input and a clue that there is something missing in this code). dog_licenses %&gt;% filter(animal_gender == &quot;M&quot;) ## Error: &lt;text&gt;:2:3: unexpected SPECIAL ## 1: dog_licenses ## 2: %&gt;% ## ^ 4.6.3 Common runtime errors Runtime errors come in an infinite number of flavors because there are so many ways that you ask for that might be impossible to do. For example you might try to do arithmetic with character strings: &quot;apple&quot; + &quot;banana&quot; ## Error in &quot;apple&quot; + &quot;banana&quot;: non-numeric argument to binary operator Or try to filter with something that isn’t a logical: dog_licenses %&gt;% filter(animal_name) ## Error: Problem with `filter()` input `..1`. ## ✖ Input `..1` must be a logical vector, not a character. ## ℹ Input `..1` is `animal_name`. Perhaps the most common runtime error is of the form Error: object not found: an_object_i_dont_have ## Error in eval(expr, envir, enclos): object &#39;an_object_i_dont_have&#39; not found This is R complaining that you’ve asked it to operate on an object that it doesn’t know about. Often this is actually a typo in disguise, for example you’ve misspelled the name of the object, my_object &lt;- 12 my_objet ## Error in eval(expr, envir, enclos): object &#39;my_objet&#39; not found you’ve used the wrong case, My_object ## Error in eval(expr, envir, enclos): object &#39;My_object&#39; not found or you’ve forgotten that you’ve used a separator myobject ## Error in eval(expr, envir, enclos): object &#39;myobject&#39; not found This error also often arises when you forgot quotes around strings. For example, if we want all the dogs that are male, and try dog_licenses %&gt;% filter(animal_gender == M) ## Error: Problem with `filter()` input `..1`. ## ✖ object &#39;M&#39; not found ## ℹ Input `..1` is `animal_gender == M`. you get an error because R is looking for an object called M to compare to the values in the column called animal_gender. What we really wanted to do was compare the values in animal_gender to the string \"M\": dog_licenses %&gt;% filter(animal_gender == &quot;M&quot;) ## # A tibble: 64,770 x 15 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 548 ROCKY M 2014-05-01 Labrador Retr… Queens ## 2 622 BULLY M 2010-07-01 American Pit … Queens ## 3 633 COCO M 2005-02-01 Labrador Retr… Queens ## 4 872 CHASE M 2013-11-01 Shih Tzu Queens ## 5 874 CHEWY M 2014-09-01 Shih Tzu Queens ## 6 875 CHASE M 2008-08-01 Labrador Retr… Queens ## 7 976 APOLLO M 2014-10-01 American Pit … Queens ## 8 1297 JERRY M 2009-06-01 Labrador Retr… Queens ## 9 2133 SIMON M 2010-12-01 Havanese Queens ## 10 2289 BUDDY M 2012-06-01 Labrador Retr… Queens ## # … with 64,760 more rows, and 9 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt; 4.6.4 Exercise: object not found Fix these object not found errors. (Hint: the names of the objects or variables being created should give you a clue to the intent of the code) dog_licenses %&gt;% mutate(year_issued = lubridate::year(Liscenceissuedate)) ## Error: Problem with `mutate()` input `year_issued`. ## ✖ object &#39;Liscenceissuedate&#39; not found ## ℹ Input `year_issued` is `lubridate::year(Liscenceissuedate)`. dogs_named_bruno &lt;- dog_licenses %&gt;% filter(animal_name == BRUNO) ## Error: Problem with `filter()` input `..1`. ## ✖ object &#39;BRUNO&#39; not found ## ℹ Input `..1` is `animal_name == BRUNO`. 4.6.5 Warnings and messages There are two other kinds of alerts R can give: warnings and messages. These can both appear in the console with the same color as an error, but they are informational as opposed to fatal. Messages are purely informational, for example when you read data in with read_csv() you get a message that describes the columns and their data types as parsed by the function: sites &lt;- read_csv(&quot;site.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## site_id = col_character(), ## latitude = col_double(), ## longitude = col_double() ## ) Warnings generally alert you that something was slightly unexpected but that R recovered and gave you a result anyway. Poorly formatted CSV files will often result in warnings from read_csv(): bad_csv &lt;- &quot; id, 1, 2 2, 1 3, 5 &quot; bad &lt;- read_csv(bad_csv) ## Warning: Missing column names filled in: &#39;X2&#39; [2] Here there was a missing column name. read_csv() still returns an object but the warning alerts you that it made some assumption to get it, i.e. that it made up a column name: bad ## # A tibble: 3 x 2 ## id X2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 ## 2 2 1 ## 3 3 5 Warnings don’t stop you from proceeding, but they should alert you to question whether you should be proceeding. 4.6.6 What do I do when I get an Error I can’t fix? Check that the error is reproducible. Restart R with a clean slate and re-run your code up to and including the code that gives the error. This is the R version of the classic tech advice to “turn it off, then turn it on again.” FIXME: link to reproducibility chapter. Try searching for it online: for example, searching for “R unexpected string constant” lead me to the question [“Error: unexpected symbol/input/string constant/numeric constant/SPECIAL in my code” on StackOverflow][error-unexpected] which gives some great examples of ways this error might arise. Ask for help. You are most likely to get help when you can provide a reproducible example. Stack Overflow has detailed instruction on how to create a [minimal reproducible example][so-mre] when asking a question to increase the chances that the question receives a specific and helpful answer. The key principles listed on the website recommends that an answer follows these guidelines: Minimal – Use as little code as possible that still produces the same problem Complete – Provide all parts someone else needs to reproduce your problem in the question itself Reproducible – Test the code you’re about to provide to make sure it reproduces the problem 4.7 How can I operate on subsets of my data? The syntax for summarise() is the same as mutate() but it expects operations that reduce all rows down to one row. Recall from mutate() that this code added the average license duration to every row of the data: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% mutate(avg_duration = mean(license_duration)) You actually saw this in one mutate() statement, but I’ve separated out the line that calculates the average so it’s easier to see the difference with summarise(). See what happens when you switch out the final mutate() with summarise(): dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% summarise(avg_duration = mean(license_duration)) ## # A tibble: 1 x 1 ## avg_duration ## &lt;drtn&gt; ## 1 467.321 days Instead of the the one value repeated on every row, we get a new tibble with only one row, and a single column that corresponds to our requested summary. Any function that takes many values and reduces them to one is a good candidate for summarise(), for example we could find the shortest licence duration by swapping in min() instead of mean(): dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% summarise(shortest_duration = min(license_duration)) ## # A tibble: 1 x 1 ## shortest_duration ## &lt;drtn&gt; ## 1 1 days Like mutate() you can also create multiple summary columns at once: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration) ) ## # A tibble: 1 x 3 ## avg_duration shortest_duration longest_duration ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; ## 1 467.321 days 1 days 2191 days Lot’s of statistical operations produce one numbers summaries and are appropriate for use with summarise(): sd(), min(), max(), mean(), median(), quantile() (with a single argument). You can see more examples in the [“Useful functions” section of the summarise() documentation][summarise-useful]. Whenever you are summarizing many rows, it’s a good idea to keep track of how many rows were summarized. This is so common, dplyr provides a special function, n(), that simply counts the number of rows. To add it to your summary: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) ## # A tibble: 1 x 4 ## avg_duration shortest_duration longest_duration n_licenses ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 467.321 days 1 days 2191 days 118542 Now, imagine you want this summary just for licenses issued to dogs in the Bronx. You might do something like: Take the dog_licenses data, and then, mutate to add a column called license_duration, and then filter to keep rows where the borough is \"Bronx\", and then summarise to find the mean, min and max duration along with the number of rows. In code: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% filter(borough == &quot;Bronx&quot;) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) ## # A tibble: 1 x 4 ## avg_duration shortest_duration longest_duration n_licenses ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 435.9884 days 2 days 1919 days 12043 But how does this compare to Brooklyn? You could do the same operation again, but now for Brooklyn: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% filter(borough == &quot;Brooklyn&quot;) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) ## # A tibble: 1 x 4 ## avg_duration shortest_duration longest_duration n_licenses ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 465.8845 days 2 days 2191 days 29334 What about Queens? This kind of operation—summarising different subsets of the same data—is so common there is a much easier way to do it: combining summarise() with group_by(). The only difference in the code, is that instead of filtering for a specific borough we’ll group_by() the column borough. dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% group_by(borough) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) ## # A tibble: 57 x 5 ## borough avg_duration shortest_duration longest_duration n_licenses ## &lt;chr&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 ARVERNE 334.0000 days 334 days 334 days 1 ## 2 Astoria 498.0000 days 239 days 757 days 2 ## 3 ASTORIA 387.6667 days 366 days 405 days 3 ## 4 B 347.0000 days 347 days 347 days 1 ## 5 Bayside 410.0000 days 410 days 410 days 1 ## 6 BELLE HARBOR 309.0000 days 309 days 309 days 1 ## 7 Briarwood 540.5000 days 358 days 723 days 2 ## 8 Bronx 435.9884 days 2 days 1919 days 12043 ## 9 BRONX 370.3333 days 72 days 418 days 102 ## 10 Brooklyn 465.8845 days 2 days 2191 days 29334 ## # … with 47 more rows The group_by() verb doesn’t perform any changes to the data except to add a signal that this data is now grouped. Subsequent operations will then happen within these groups. In the case of summarise() we now get one row per group, and these are all stacked together in our result. You might have been a little surprised by the result above. I thought there were only five boroughs in New York (at least that’s what the Beastie Boys told me). Notice some boroughs are represented more than once by variations in case or spelling: Bronx, BRONX. As far as group_by() is concerned these are distinct values of this variable. There also seem to be smaller designations than Borough in this data. You’ll get a chance to try and resolve this in an exercise below. 4.7.1 Exercise: Dog birth months The following code creates a new column month_born that holds the name of the month the licensed dog was born: dog_licenses %&gt;% mutate(month_born = lubridate::month(animal_birth_month, label = TRUE)) Use a group_by() step and a summarise() step to find the number of dogs born in each month. Which month stands out? Can you guess why? 4.7.2 Exercise: Order matters? In the example above for dogs licensed in Brooklyn: dog_licenses %&gt;% mutate(license_duration = license_expired_date - license_issued_date) %&gt;% filter(borough == &quot;Brooklyn&quot;) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) the filter() step came after the mutate() step. Does this matter? Swap the order in the code and see if you get the same results. Write out how you might describe the steps. Is it obvious you can swap the filter and mutate step and get the same results? Which steps can’t you swap the order of? Why? Despite giving the same results, some orderings of the data manipulation steps will take longer to compute. Can you guess why? 4.7.3 Exercise: the five boroughs The column neighborhood_tabulation_area is a code for the “Neighborhood Tabulation Areas,” and has been geo-coded from the licensee’s address (as opposed to self reported). The first two characters correspond to the Borough. This code creates a new variable called borough_code that contains just these two characters: dog_licenses %&gt;% mutate(borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) ## # A tibble: 118,542 x 16 ## row_number animal_name animal_gender animal_birth_mon… breed_name borough ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 533 BONITA F 2013-05-01 Unknown Queens ## 2 548 ROCKY M 2014-05-01 Labrador Retr… Queens ## 3 622 BULLY M 2010-07-01 American Pit … Queens ## 4 633 COCO M 2005-02-01 Labrador Retr… Queens ## 5 655 SKI F 2012-09-01 American Pit … Queens ## 6 872 CHASE M 2013-11-01 Shih Tzu Queens ## 7 874 CHEWY M 2014-09-01 Shih Tzu Queens ## 8 875 CHASE M 2008-08-01 Labrador Retr… Queens ## 9 893 MILEY F 2008-07-01 Boxer Queens ## 10 919 KENZI F 2010-05-01 Schnauzer, Mi… Queens ## # … with 118,532 more rows, and 10 more variables: zip_code &lt;dbl&gt;, ## # community_district &lt;dbl&gt;, census_tract_2010 &lt;dbl&gt;, ## # neighborhood_tabulation_area &lt;chr&gt;, city_council_district &lt;dbl&gt;, ## # congressional_district &lt;dbl&gt;, state_senatorial_district &lt;dbl&gt;, ## # license_issued_date &lt;date&gt;, license_expired_date &lt;date&gt;, borough_code &lt;chr&gt; Which borough has the longest average licence duration? 4.8 How can I read my own tabular data into R? 4.8.1 What is tabular data? Tabular data describes data that is in the form of a table: values arranged in rows each of the same length, or equivalently values arranged in columns each of the same length. Here’s a small example of some tabular data: site_id latitude longitude DR-1 -49.85 -128.57 DR-3 -47.15 -126.72 MSK-4 -48.87 -123.40 Each row records information on a site at which water measurements are taken. There are three columns: a site identification code, and the location of the site in latitude and longitude. This is an incredibly common way of displaying data, but when storing tabular data in a file, we need a way to communicate when records and values begin and end. A very popular format for doing this is CSV. CSV, is short for comma separated values, and like the name suggests, a comma, ,, is used to separate the values for each column, while each record goes on a new line. The file is plain text, but we use the extension .csv to indicate that is follows the CSV format conventions. Here’s how the table above would look inside the CSV file site.csv: site_id,latitude,longitude DR-1,-49.85,-128.57 DR-3,-47.15,-126.72 MSK-4,-48.87,-123.4 In this case the first line has the column names, this is common (and recommended!), but not universal. Why is CSV so popular? It’s human readable. CSV isn’t a special file type, it is a simple plain text file that follows some conventions. This means you don’t need any special software to look at the contents—you can open it up in anything that can examine text and take a look inside. It’s computer readable. Because CSV files all have the same structure it’s easy to write computer programs to read them. This means in almost any program designed to work with data, which is basically all the common programming languages, you’ll find functions that will import CSV files. This also means it’s easy to create CSV files—you can export them from Excel, write them from R, or even write one from scratch in a text editor. If you want to look inside a CSV file in RStudio you can navigate to its location in the “Files” pane and click on its name. Selecting “View File,” will open it in the Source pane. However, if you want to work with CSV data in R, it isn’t enough to look inside the file. You need to read the contents of the file and store it in R’s memory. This process is known as data import. 4.8.2 Importing CSV data into R To work with data in R you need to have it in R’s memory. The read_csv() function in the readr package will import a CSV file, and represent it as a tibble, if you give it the location of the CSV file. For example, to read the site.csv data and store it in an object called sites: library(tidyverse) sites &lt;- read_csv(here(&quot;data&quot;, &quot;site.csv&quot;)) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## site_id = col_character(), ## latitude = col_double(), ## longitude = col_double() ## ) sites ## # A tibble: 3 x 3 ## site_id latitude longitude ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DR-1 -49.8 -129. ## 2 DR-3 -47.2 -127. ## 3 MSK-4 -48.9 -123. FIXME: talk about files paths, point reader to the place where file paths are talked about, or assume file is in their working directory. Notice that read_csv() gave us a message about what it did: it parsed our data file and found three columns site_id, latitude and longitude. It also mentions what kind of data it assumed was in each column. FIXME: point to further discussion of data types. The object sites is now R’s representation of the data from the site.csv file. 4.8.3 Exercise: Import visited.csv Use read_csv() to read visited.csv into R. How does R indicate a cell with a missing value? visited &lt;- read_csv(here(&quot;data&quot;, &quot;visited.csv&quot;)) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## visit_id = col_double(), ## site_id = col_character(), ## visit_date = col_date(format = &quot;&quot;) ## ) visited ## # A tibble: 8 x 3 ## visit_id site_id visit_date ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 619 DR-1 1927-02-08 ## 2 622 DR-1 1927-02-10 ## 3 734 DR-3 1930-01-07 ## 4 735 DR-3 1930-01-12 ## 5 751 DR-3 1930-02-26 ## 6 752 DR-3 NA ## 7 837 MSK-4 1932-01-14 ## 8 844 DR-1 1932-03-22 4.8.4 Exercise: Import IRS tax return data for New York City Use read_csv() to import the CSV file nyc-tax-returns.csv. FIXME: Should we introduce the “common things that go wrong” / “the most common additional arguments,” e.g. skip, na, col_names, col_types? My feeling is not now, but sometime later. 4.9 How can I save my results? Say, you’ve now got a summary of the license durations by borough: dog_licenses %&gt;% mutate( license_duration = license_expired_date - license_issued_date, borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) %&gt;% group_by(borough_code) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) ## # A tibble: 5 x 5 ## borough_code avg_duration shortest_duration longest_duration n_licenses ## &lt;chr&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 BK 465.2768 days 2 days 2191 days 29558 ## 2 BX 435.8062 days 2 days 1919 days 12050 ## 3 MN 494.0276 days 1 days 2189 days 41668 ## 4 QN 452.1386 days 2 days 2186 days 24420 ## 5 SI 439.4875 days 4 days 2164 days 10846 How do you save this result for future use? If you just need this tibble later in your code you can assign it to a variable: duration_by_borough &lt;- dog_licenses %&gt;% mutate( license_duration = license_expired_date - license_issued_date, borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) %&gt;% group_by(borough_code) %&gt;% summarise( avg_duration = mean(license_duration), shortest_duration = min(license_duration), longest_duration = max(license_duration), n_licenses = n() ) Then you can access it whenever you need it: duration_by_borough ## # A tibble: 5 x 5 ## borough_code avg_duration shortest_duration longest_duration n_licenses ## &lt;chr&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 BK 465.2768 days 2 days 2191 days 29558 ## 2 BX 435.8062 days 2 days 1919 days 12050 ## 3 MN 494.0276 days 1 days 2189 days 41668 ## 4 QN 452.1386 days 2 days 2186 days 24420 ## 5 SI 439.4875 days 4 days 2164 days 10846 This keeps our result around in memory, but often you also want to preserve the data in a file on disk. There are two common choices for format: CSV and RDS. You’ve already seen CSV files. Saving your results in this format gives you all the benefits of that format: plain text files easily shared and opened. You can save a tibble as a CSV file with the readr function write_csv(), where all you need to specify is the path: duration_by_borough %&gt;% write_csv(&quot;duration-by-borough.csv&quot;) You can then read this file in any project or R session with read_csv(): duration_by_borough &lt;- read_csv(&quot;duration-by-borough.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## borough_code = col_character(), ## avg_duration = col_double(), ## shortest_duration = col_double(), ## longest_duration = col_double(), ## n_licenses = col_double() ## ) RDS files are a special R format. They are binary files as opposed to plain text files, which means you can’t just open them up and look inside. If you are sharing them you’d also need your collaborators to have R. These are downsides, but the advantage of this format is that it can be much quicker to load, it will preserve special R data types (for example factors, or nested structures), and can save any R object not just tabular data structures. To save the tibble as an RDS, use write_rds(): duration_by_borough %&gt;% write_rds(&quot;duration-by-borough.rds&quot;) To read it back in, use read_rds(): duration_by_borough &lt;- read_rds(&quot;duration-by-borough.rds&quot;) Often you’ll save your data in both formats to make sure you get the best of both worlds. You’ll talk more about where to save your data in FIXME: add link. 4.9.1 Exercise Save the tibble with our extra columns: dog_licenses %&gt;% mutate( license_duration = license_expired_date - license_issued_date, borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) into a CSV file called dog-licenses-extra.csv. "],["practice.html", "Chapter 5 Practice 5.1 Working with a single tidy table 5.2 Working with grouped data 5.3 Creating charts", " Chapter 5 Practice We have covered a lot in the last few lessons, so this one presents some practice exercises to ground what we have learned and introduce a few more commonly-used functions. 5.1 Working with a single tidy table Load the tidyverse collection of package and the here package for constructing paths: library(tidyverse) library(here) Use here::here to construct a path to a file and readr::read_csv to read that file: path &lt;- here::here(&quot;data&quot;, &quot;person.csv&quot;) person &lt;- readr::read_csv(path) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## person_id = col_character(), ## personal_name = col_character(), ## family_name = col_character() ## ) person ## # A tibble: 5 x 3 ## person_id personal_name family_name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 dyer William Dyer ## 2 pb Frank Pabodie ## 3 lake Anderson Lake ## 4 roe Valentina Roerich ## 5 danforth Frank Danforth Read survey/site.csv. Count rows and columns using nrow and ncol: nrow(person) ## [1] 5 ncol(person) ## [1] 3 How many rows and columns are in the site data? Format strings using glue::glue: print(glue::glue(&quot;person has {nrow(person)} rows and {ncol(person)} columns&quot;)) ## person has 5 rows and 3 columns Print a nicely-formatted summary of the number of rows and columns in the site data. Use colnames to get the names of columns and paste to join strings together: print(glue::glue(&quot;person columns are {paste(colnames(person), collapse = &#39; &#39;)}&quot;)) ## person columns are person_id personal_name family_name Print a nicely-formatted summary of the names of the columns in the site data. Use dplyr::select to create a new table with a subset of columns by name: dplyr::select(person, family_name, personal_name) ## # A tibble: 5 x 2 ## family_name personal_name ## &lt;chr&gt; &lt;chr&gt; ## 1 Dyer William ## 2 Pabodie Frank ## 3 Lake Anderson ## 4 Roerich Valentina ## 5 Danforth Frank Create a table with just the latitudes and longitudes of sites. Use dplyr::filter to create a new table with a subset of rows by values: dplyr::filter(person, family_name &lt; &quot;M&quot;) ## # A tibble: 3 x 3 ## person_id personal_name family_name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 dyer William Dyer ## 2 lake Anderson Lake ## 3 danforth Frank Danforth Create a table with only sites south of -48 degrees. Use the pipe operator %&gt;% to combine operations: person %&gt;% dplyr::select(family_name, personal_name) %&gt;% dplyr::filter(family_name &lt; &quot;M&quot;) ## # A tibble: 3 x 2 ## family_name personal_name ## &lt;chr&gt; &lt;chr&gt; ## 1 Dyer William ## 2 Lake Anderson ## 3 Danforth Frank Create a table with only the latitudes and longitudes of sites south of -48 degrees. Use dplyr::mutate to create a new column with calculated values and stringr::str_length to calculate string length: person %&gt;% dplyr::mutate(name_length = stringr::str_length(family_name)) ## # A tibble: 5 x 4 ## person_id personal_name family_name name_length ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dyer William Dyer 4 ## 2 pb Frank Pabodie 7 ## 3 lake Anderson Lake 4 ## 4 roe Valentina Roerich 7 ## 5 danforth Frank Danforth 8 Look at the help for the built-in function round and then use it to create a table with latitudes and longitudes rounded to integers. Use dplyr::arrange to order rows and (optionally) dplyr::desc to impose descending order: person %&gt;% dplyr::mutate(name_length = stringr::str_length(family_name)) %&gt;% dplyr::arrange(dplyr::desc(name_length)) ## # A tibble: 5 x 4 ## person_id personal_name family_name name_length ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 danforth Frank Danforth 8 ## 2 pb Frank Pabodie 7 ## 3 roe Valentina Roerich 7 ## 4 dyer William Dyer 4 ## 5 lake Anderson Lake 4 Create a table sorted by decreasing longitude (i.e., most negative longitude last). 5.2 Working with grouped data Read survey/measurements.csv and look at the data with View: measurements &lt;- readr::read_csv(here::here(&quot;data&quot;, &quot;measurements.csv&quot;)) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## visit_id = col_double(), ## visitor = col_character(), ## quantity = col_character(), ## reading = col_double() ## ) View(measurements) Find rows where reading is not NA, save as cleaned, and report how many rows were removed: cleaned &lt;- measurements %&gt;% dplyr::filter(!is.na(reading)) nrow(measurements) - nrow(cleaned) ## [1] 1 Rewrite the filter expression to select rows where the visitor and quantity are not NA either and report the total number of rows removed. Group measurements by quantity measured and count the number of each (the column is named n automatically): cleaned %&gt;% dplyr::group_by(quantity) %&gt;% dplyr::count() ## # A tibble: 3 x 2 ## # Groups: quantity [3] ## quantity n ## &lt;chr&gt; &lt;int&gt; ## 1 rad 8 ## 2 sal 7 ## 3 temp 3 Group by person and quantity measured. Find the minimum, average, and maximum for each quantity: cleaned %&gt;% dplyr::group_by(quantity) %&gt;% dplyr::summarize(low = min(reading), mid = mean(reading), high = max(reading)) ## # A tibble: 3 x 4 ## quantity low mid high ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 rad 1.46 6.56 11.2 ## 2 sal 0.05 9.24 41.6 ## 3 temp -21.5 -18.7 -16 Look at the range for each combination of person and quantity. Rescale salinity measurements that are greater than 1: cleaned &lt;- cleaned %&gt;% dplyr::mutate(reading = ifelse(quantity == &#39;sal&#39; &amp; reading &gt; 1.0, reading/100, reading)) cleaned ## # A tibble: 18 x 4 ## visit_id visitor quantity reading ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 619 dyer rad 9.82 ## 2 619 dyer sal 0.13 ## 3 622 dyer rad 7.8 ## 4 622 dyer sal 0.09 ## 5 734 pb rad 8.41 ## 6 734 lake sal 0.05 ## 7 734 pb temp -21.5 ## 8 735 pb rad 7.22 ## 9 751 pb rad 4.35 ## 10 751 pb temp -18.5 ## 11 752 lake rad 2.19 ## 12 752 lake sal 0.09 ## 13 752 lake temp -16 ## 14 752 roe sal 0.416 ## 15 837 lake rad 1.46 ## 16 837 lake sal 0.21 ## 17 837 roe sal 0.225 ## 18 844 roe rad 11.2 Do the same calculation use case_when. Read visited.csv, drop the NAs and store in visits. Use anti_join() to find the measurements in cleaned that don’t have matches in visits: visits &lt;- readr::read_csv(here::here(&quot;data&quot;, &quot;visited.csv&quot;)) %&gt;% dplyr::filter(!is.na(visit_date)) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## visit_id = col_double(), ## site_id = col_character(), ## visit_date = col_date(format = &quot;&quot;) ## ) cleaned %&gt;% anti_join(visits) ## Joining, by = &quot;visit_id&quot; ## # A tibble: 4 x 4 ## visit_id visitor quantity reading ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 752 lake rad 2.19 ## 2 752 lake sal 0.09 ## 3 752 lake temp -16 ## 4 752 roe sal 0.416 Are there any sites in visits that don’t have matches in cleaned? Join visits with the cleaned-up table of readings: cleaned &lt;- visits %&gt;% dplyr::inner_join(cleaned, by = c(&quot;visit_id&quot; = &quot;visit_id&quot;)) cleaned ## # A tibble: 14 x 6 ## visit_id site_id visit_date visitor quantity reading ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 619 DR-1 1927-02-08 dyer rad 9.82 ## 2 619 DR-1 1927-02-08 dyer sal 0.13 ## 3 622 DR-1 1927-02-10 dyer rad 7.8 ## 4 622 DR-1 1927-02-10 dyer sal 0.09 ## 5 734 DR-3 1930-01-07 pb rad 8.41 ## 6 734 DR-3 1930-01-07 lake sal 0.05 ## 7 734 DR-3 1930-01-07 pb temp -21.5 ## 8 735 DR-3 1930-01-12 pb rad 7.22 ## 9 751 DR-3 1930-02-26 pb rad 4.35 ## 10 751 DR-3 1930-02-26 pb temp -18.5 ## 11 837 MSK-4 1932-01-14 lake rad 1.46 ## 12 837 MSK-4 1932-01-14 lake sal 0.21 ## 13 837 MSK-4 1932-01-14 roe sal 0.225 ## 14 844 DR-1 1932-03-22 roe rad 11.2 Join visited.csv with site.csv to get (date, latitude, longitude) triples for site visits. Find the dates of the highest radiation reading at each site: cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::mutate(max_rad = max(reading)) %&gt;% dplyr::filter(reading == max_rad) ## # A tibble: 3 x 7 ## # Groups: site_id [3] ## visit_id site_id visit_date visitor quantity reading max_rad ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 734 DR-3 1930-01-07 pb rad 8.41 8.41 ## 2 837 MSK-4 1932-01-14 lake rad 1.46 1.46 ## 3 844 DR-1 1932-03-22 roe rad 11.2 11.2 Another way to do it: cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::top_n(1, reading) %&gt;% dplyr::select(site_id, visit_date, reading) ## # A tibble: 3 x 3 ## # Groups: site_id [3] ## site_id visit_date reading ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 DR-3 1930-01-07 8.41 ## 2 MSK-4 1932-01-14 1.46 ## 3 DR-1 1932-03-22 11.2 Explain why this doesn’t work. cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::summarize(max_rad = max(reading)) %&gt;% dplyr::ungroup() %&gt;% dplyr::filter(reading == max_rad) ## Error: Problem with `filter()` input `..1`. ## ✖ object &#39;reading&#39; not found ## ℹ Input `..1` is `reading == max_rad`. Normalize radiation against the highest radiation seen per site: cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::mutate( max_rad = max(reading), frac_rad = reading / max_rad) %&gt;% dplyr::select(visit_id, site_id, visit_date, frac_rad) ## # A tibble: 7 x 4 ## # Groups: site_id [3] ## visit_id site_id visit_date frac_rad ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 619 DR-1 1927-02-08 0.873 ## 2 622 DR-1 1927-02-10 0.693 ## 3 734 DR-3 1930-01-07 1 ## 4 735 DR-3 1930-01-12 0.859 ## 5 751 DR-3 1930-02-26 0.517 ## 6 837 MSK-4 1932-01-14 1 ## 7 844 DR-1 1932-03-22 1 Normalize salinity against mean salinity by site. Find stepwise change in radiation per site by date: cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::mutate(delta_rad = reading - dplyr::lag(reading)) %&gt;% dplyr::arrange(site_id, visit_date) ## # A tibble: 7 x 7 ## # Groups: site_id [3] ## visit_id site_id visit_date visitor quantity reading delta_rad ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 619 DR-1 1927-02-08 dyer rad 9.82 NA ## 2 622 DR-1 1927-02-10 dyer rad 7.8 -2.02 ## 3 844 DR-1 1932-03-22 roe rad 11.2 3.45 ## 4 734 DR-3 1930-01-07 pb rad 8.41 NA ## 5 735 DR-3 1930-01-12 pb rad 7.22 -1.19 ## 6 751 DR-3 1930-02-26 pb rad 4.35 -2.87 ## 7 837 MSK-4 1932-01-14 lake rad 1.46 NA Find length of time between visits by site. Find sites that experience any stepwise increase in radiation between visits: cleaned %&gt;% dplyr::filter(quantity == &quot;rad&quot;) %&gt;% dplyr::group_by(site_id) %&gt;% dplyr::mutate(delta_rad = reading - dplyr::lag(reading)) %&gt;% dplyr::filter(!is.na(delta_rad)) %&gt;% dplyr::summarize(any_increase = any(delta_rad &gt; 0)) %&gt;% dplyr::filter(any_increase) ## # A tibble: 1 x 2 ## site_id any_increase ## &lt;chr&gt; &lt;lgl&gt; ## 1 DR-1 TRUE Find sites with visits more than one year apart. 5.3 Creating charts We will use data on the mass and home range area (HRA) of various species from: Tamburello N, Côté IM, Dulvy NK (2015) Data from: Energy and the scaling of animal space use. Dryad Digital Repository. https://doi.org/10.5061/dryad.q5j65 hra &lt;- readr::read_csv(here::here(&quot;data&quot;, &quot;home-range-database.csv&quot;)) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## .default = col_character(), ## mean.mass.g = col_double(), ## log10.mass = col_double(), ## mean.hra.m2 = col_double(), ## log10.hra = col_double(), ## preymass = col_double(), ## log10.preymass = col_double(), ## PPMR = col_double() ## ) ## ℹ Use `spec()` for the full column specifications. head(hra) ## # A tibble: 6 x 24 ## taxon common.name class order family genus species primarymethod N ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 lake f… american eel actino… anguil… angui… angu… rostra… telemetry 16 ## 2 river … blacktail re… actino… cyprin… catos… moxo… poecil… mark-recaptu… &lt;NA&gt; ## 3 river … central ston… actino… cyprin… cypri… camp… anomal… mark-recaptu… 20 ## 4 river … rosyside dace actino… cyprin… cypri… clin… fundul… mark-recaptu… 26 ## 5 river … longnose dace actino… cyprin… cypri… rhin… catara… mark-recaptu… 17 ## 6 river … muskellunge actino… esocif… esoci… esox masqui… telemetry 5 ## # … with 15 more variables: mean.mass.g &lt;dbl&gt;, log10.mass &lt;dbl&gt;, ## # alternative.mass.reference &lt;chr&gt;, mean.hra.m2 &lt;dbl&gt;, log10.hra &lt;dbl&gt;, ## # hra.reference &lt;chr&gt;, realm &lt;chr&gt;, thermoregulation &lt;chr&gt;, locomotion &lt;chr&gt;, ## # trophic.guild &lt;chr&gt;, dimension &lt;chr&gt;, preymass &lt;dbl&gt;, log10.preymass &lt;dbl&gt;, ## # PPMR &lt;dbl&gt;, prey.size.reference &lt;chr&gt; Look at how mass is distributed: ggplot2::ggplot(hra, mapping = aes(x = mean.mass.g)) + ggplot2::geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Try again with log10.mass: ggplot2::ggplot(hra, mapping = aes(x = log10.mass)) + ggplot2::geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Create histograms showing the distribution of home range area using linear and log scales. Change the visual appearance of a chart: ggplot2::ggplot(hra, mapping = aes(x = log10.mass)) + ggplot2::geom_histogram(bins = 100) + ggplot2::ggtitle(&quot;Frequency of Species Masses&quot;) + ggplot2::xlab(&quot;Log10 of Mass&quot;) + ggplot2::ylab(&quot;Number of Species&quot;) + ggplot2::theme_minimal() Show the distribution of home range areas with a dark background. Create a scatterplot showing the relationship between mass and home range area: ggplot2::ggplot(hra, mapping = aes(x = log10.mass, y = log10.hra)) + ggplot2::geom_point() Create a similar scatterplot showing the relationship between the raw values rather than the log values. Colorize scatterplot points by class: hra %&gt;% dplyr::mutate(class_fct = as.factor(class)) %&gt;% ggplot2::ggplot(mapping = aes(x = log10.mass, y = log10.hra, color = class_fct)) + ggplot2::geom_point(alpha = 0.5) Group by order and experiment with different alpha values. Create a faceted plot: hra %&gt;% dplyr::mutate(class_fct = as.factor(class)) %&gt;% ggplot2::ggplot(mapping = aes(x = log10.mass, y = log10.hra, color = class_fct)) + ggplot2::geom_point(alpha = 0.5) + ggplot2::facet_wrap(vars(class_fct)) Create a plot faceted by order for just the reptiles. Fit a linear regression to the logarithmic data for birds: hra %&gt;% dplyr::filter(class == &quot;aves&quot;) %&gt;% ggplot2::ggplot(mapping = aes(x = log10.mass, y = log10.hra)) + ggplot2::geom_point(alpha = 0.5) + ggplot2::geom_smooth(method = lm, color = &#39;red&#39;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; Fit a line to the raw data for birds rather than the logarithmic data. Create a violin plot of mass by order for birds: hra %&gt;% dplyr::filter(class == &quot;aves&quot;) %&gt;% dplyr::mutate(order_fct = as.factor(order)) %&gt;% ggplot2::ggplot(mapping = aes(x = order_fct, y = log10.mass, color = order_fct)) + ggplot2::geom_violin() Rotate the labels on the X axis to make this readable, then explain the gaps. Display the same data as a boxplot: hra %&gt;% dplyr::filter(class == &quot;aves&quot;) %&gt;% dplyr::mutate(order_fct = as.factor(order)) %&gt;% ggplot2::ggplot(mapping = aes(x = order_fct, y = log10.mass, color = order_fct)) + ggplot2::geom_boxplot() Fix the labels and remove orders that only contain one species. Save the linear regression plot for birds as a PNG: hra %&gt;% dplyr::filter(class == &quot;aves&quot;) %&gt;% ggplot2::ggplot(mapping = aes(x = log10.mass, y = log10.hra)) + ggplot2::geom_point(alpha = 0.5) + ggplot2::geom_smooth(method = lm, color = &#39;red&#39;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; ggsave(here::here(&quot;birds.png&quot;)) ## Saving 7 x 5 in image ## `geom_smooth()` using formula &#39;y ~ x&#39; Save the plot as SVG scaled to be 8cm wide. Create a horizontal histogram with 50 bins: ggplot2::ggplot(hra, mapping = aes(x = log10.mass)) + ggplot2::geom_histogram(bins = 50) + ggplot2::coord_flip() Use stat_summary to summarize the relationship between mass and home range area by class. "],["publishing.html", "Chapter 6 Publishing 6.1 Objectives 6.2 Why should I share my work on the internet? 6.3 What does it take to get a webpage online? 6.4 How do I get my work on the web? 6.5 How do I link to other pages, files or images? 6.6 Exercise: Add a website to an existing project", " Chapter 6 Publishing 6.1 Objectives 6.2 Why should I share my work on the internet? A key part of any project is communicating what you have learned. You’ve already seen how to create documents to communicate your work with R Markdown, and how to host whole projects on GitHub. This chapter is about sharing your work through a webpage on the internet. Some advantages of sharing your work on a webpage include: It’s easy for your visitors—they just need to click on a link and see your work. They don’t need to know anything about R Markdown, HTML, or GitHub. It provides a visually friendly and customizable landing point for people interested in your project. You can easily point them to the GitHub repo if they want more details. It’s easy for you to make updates and those updates are immediately available to any visitors—you don’t have to re-send anyone any files. By the end of this chapter, you’ll be able to take an R Markdown document that lives on your computer and share it with the world through a link to your own webpage. 6.3 What does it take to get a webpage online? To understand what it takes to get a webpage online, it helps to understand roughly what happens when you point your browser at a web address. When you point your browser at an address, for example https://merely-useful.github.io/r-publishing.html, the following things happen: The URL https://merely-useful.github.io points to a location on another computer where the relevant files for this website reside. This computer is known as the website host or server, since it hosts the webpage files on its local storage drives and serves them to us via the internet. The browser requests the file r-publishing.html from the host. The browser reads the contents of r-publishing.html and displays it for you in the browser window. In reverse order this process also describes what you need to do to get your own website online: You need an HTML file that describes what people should see on your page. You need to host the HTML file on a computer on the internet. You need a way to associate a URL with the address of your host. In this chapter, you’ll learn a process for getting your work online that leverages what you already know—creating HTML files using R Markdown (#1 above) and how to host your work in a GitHub repository (#2). The third step will be handled by a GitHub service called [GitHub Pages][gh-pages]. By following the conventions that GitHub Pages expects, you’ll be able to make a webpage for any of your repositories available at: http://{{your_username}}.github.io/{{repo_name}}. 6.4 How do I get my work on the web? 6.4.1 A starting point FIXME: revisit this later when more content is fleshed out. Maybe there will be a repo we can rely on all learners having that we can start from. In practice you’ll probably start thinking about a website once you’ve already done a lot of work on a project—your project will already have some analysis documented in R Markdown, be in version control, and hosted on GitHub. However, so that we can work with a specific example, you’ll set up a project in this section that is less developed than where your project might be when you start thinking about making a website. At the end of this section, you should have an RStudio project with an example report in report.Rmd. This project should also be on GitHub at https://github.com/{{your_username}}/sharing-work, where {{your_username}} should be substituted with your GitHub username, e.g. mine is at https://github.com/cwickham/sharing-work. Let’s start by creating a new project called, sharing-work by running the following in the RStudio console: usethis::create_project(&quot;sharing-work&quot;) Once the project opens, set it up to use version control by running the next code in the Console: usethis::use_git() Then add it as a repository on GitHub: usethis::use_github() Then so we have a report to work with, create a new R Markdown file (“File -&gt; New File -&gt; R Markdown”), making sure to leave the “Default Output Format” as HTML. Save this new file as report.Rmd. Commit these changes and push your repository to GitHub. This is our starting point. FIXME: Would it be better to get to this point by getting learners to fork a repo, then “New project -&gt; From version control” in RStudio? Except forking isn’t in the plan for the Version Control section. 6.4.2 HTML files If you Knit report.Rmd you’ll get report.html, an HTML document, because in the header of report.Rmd output is set to html_document. In the Files pane in RStudio if you click on report.html, you’ll get two options: Open in Editor, or Display in Web Browser. HTML is the language of webpages. If you “Open in Editor” you will see the contents of the file—it’s plain text with markup tags to indicate how web browsers should display the text. If you “View in Web Browser” your browser will read, interpret and display the HTML for you. When you “View in Web Browser” you may notice the address bar in your browser looks something like: file:///Users/wickhamc/Documents/Projects/sharing-work/docs/report.html Just as https:// is a signal that a file resides on a remote server computer, file:// is a signal that a file lives on your computer locally. In spite of having “web” in their name, web browsers perfectly display local files as long as they are in a suitable format, such as HTML. However, you couldn’t give this local address to someone else and expect it to work, because they don’t have this file on their computer. The HTML produced by R Markdown is completely self-contained, the browser needs no additional files to display the page as you see it now. So, you could email the file report.html, and your recipients could open it their browser and see the same result. However, our goal will be to put this HTML file on the web so you can share a link to the file instead of the file itself. You’ll start by having this file accessible at the link https://{{your_username}}.github.io/sharing-work/report.html, then learn how to have it displayed with the shorter link https://{{your_username}}.github.io/sharing-work 6.4.3 Setting up your repo to have a web page Our goal is to get the report that is currently living in report.html displayed when a visitor heads to https://{{your_username}}.github.io/sharing-work You’ll set up GitHub Pages to look for your HTML files in the docs directory. Your first step will be to make this directory and put our report file inside. Create docs/ with: usethis::use_directory(&quot;docs&quot;) Move report.Rmd and report.html into this directory. You can do this within the Files pane by checking the files and “More -&gt; Move….” Or you can do it with code on the Console: file.rename(&quot;report.Rmd&quot;, &quot;docs/report.Rmd&quot;) file.rename(&quot;report.html&quot;, &quot;docs/report.html&quot;) Commit and push your changes. Your repo should now have a structure like: ├── docs │ ├── report.Rmd │ └── report.html └── sharing-work.Rproj Now you will activate GitHub Pages, so that GitHub will know to deliver your files when visitors head to: https://{{your_username}}.github.io/sharing-work Visit your GitHub Repository and head to the “Settings” tab. Scroll to the “GitHub Pages” section. Activate GitHub pages, with source set to “master branch /docs folder.” You should see a message that your site is now live at: https://{{your_username}}.github.io/sharing-work Try visiting: https://{{your_username}}.github.io/sharing-work/report.html. You should see your report. Congratulations you have a webpage! 6.4.4 Getting a default page to display when people visit the project site You could send people the link, https://{{your_username}}.github.io/sharing-work/report.html, but it is often nicer to send them the shorter version without the file name: https://{{your_username}}.github.io/sharing-work. You can try this now, but it won’t work—you’ll see a message in your browser like: “404- File not found.” This shorter URL points to a directory as opposed to a file. By default, when a server receives a request for a directory, it looks for a file to display with a default name—usually index.html. In your case there is no file called index.html so there is nothing to display. If you would like the contents of report.html to be displayed as the homepage of your project, then rename report.Rmd to index.Rmd. You’ll then need to regenerate the HTML file, commit it, and push your changes. For work that is communicated easily in one page, this would be a good option. Alternatively, you might have a different page as the default page—one that summarizes the project and then links to other more detailed pages. You’ll see how to do this over the next few sections. To get started create a new R Markdown document. Delete all the contents of the file, and then copy and paste in the following: --- title: &quot;Sharing work on a webpage&quot; author: &quot;Me&quot; output: html_document --- This project ... * Read my report * Visit this project on GitHub Save the file as index.Rmd, knit it, commit, and push your changes. Your repo should now look like: ├── docs │ ├── index.Rmd │ ├── index.html │ ├── report.Rmd │ └── report.html └── sharing-work.Rproj Now when you visit https://{{your_username}}.github.io/sharing-work you should see: Note that it might take some time for the webpage to refresh automatically and detect the new index file. You can trigger this manually by going to GitHub Pages settings and changes the source branch to something else than docs/ and then back again. 6.4.5 What does it take to get your work on a webpage? To sum up the process above, in its most minimal form, to have a webpage at https://{{your_username}}.github.io/{{repo_name}}, your repo at https://github.com/{{your_username}}/{{repo_name}} needs to: have an index.html file in the docs directory (probably generated from index.Rmd in the same location), and have GitHub Pages activated in repository settings with source set to “master branch /docs folder.” Be aware that everything inside the docs folder is now public, even if your repository is private. You might have noticed this book lives at a GitHub Pages URL without a repo name—there is nothing after the .io in https://merely-useful.github.io. Both GitHub organizations and individuals can make use of this shorter address format (merely-useful is an organization rather than a user, so this is an organization site). There are a few differences between what you’ve learnt so far and the process of setting up a user site without a repo name (at https://{{your_username}}.github.io). First, you need to name your repository in a specific way—it must be called {{your_username}}.github.io. Second, user sites don’t use the docs/ folder—you put your HTML files at the top level in the repo. And third, you don’t have to change any settings with user sites—GitHub will recognize the repo name and automatically serve it at https://{{your_username}}.github.io. 6.4.6 Exercise: Customize index.Rmd Edit index.Rmd to have your name as the author. Knit index.Rmd to verify your changes, then commit and push them. Visit https://{{your_username}}.github.io/sharing-work to check the updated site. This is the workflow for making changes to your webpage. Make edits locally, and Knit to check them. Then commit and push to make those changes visible on the web. 6.5 How do I link to other pages, files or images? 6.5.1 Linking to other pages To create a link to another page in markdown file you use the syntax: [text to display](url) Once Knit to HTML, only text to display will be visible, and clicking on the text will take a viewer to url. For example, to add a link to my GitHub repo I might add the following line to index.Rmd: Visit [my github repo](https://www.github.com/cwickham/sharing-work) Which when Knit to HTML renders like: Visit my github repo This is an example of an absolute URL. Just like when you specify file paths on your own computer, URLs can be both absolute and relative. An absolute URL describes a file location starting from and including the domain name. For instance, the absolute URL that points to report.html in my repo is https://cwickham.github.io/sharing-work/report.html. Relative URLs are relative to the current HTML file. So, for instance if you are viewing https://cwickham.github.io/sharing-work/index.html, a relative link to my report.html would be report.html since this file is at the same level as index.html in my website structure. For pages created using this GitHub Pages workflow, your website structure is the same as the file structure in your docs/ folder. To add a link to report.html in index.Rmd I would add a line like: See the [full report](report.html) You should use relative URLs to reference any of your files (i.e. those in docs/). That way if you ever rename your repository, move it, or use a different hosting platform, your links will all work without changes. You must use absolute links for files that reside elsewhere on the internet. 6.5.2 Exercise: Relative links Imagine your docs/ folder had the following structure: ├── docs │ ├── index.Rmd │ ├── index.html │ ├── diagrams │ │ └── workflow.png | ├── reports | │ ├── jan.Rmd | │ ├── jan.html | │ ├── feb.Rmd | │ └── feb.html └── sharing-work.Rproj Using a relative URL, how would you refer to: jan.html from index.html? feb.html from jan.html? workflow.png from index.html? 6.5.3 Exercise: Add links to index.html Add to index.Rmd: a link to report.html using a relative link, and a link your GitHub repository using an absolute link. 6.5.4 Linking to sections within a page URLs can also refer to places inside the current page, most usually to another section. In R Markdown you’ve seen how to create headings using #. For example, an Appendix subsection might be: ## Appendix If we want to link to this section from elsewhere, you prefix the section name with a single # in the URL. For example, if this section is in report.Rmd and you want to link to it elsewhere in report.Rmd, you could use: See more details in the [appendix](#appendix) The URL #appendix is interpreted as the heading with ID appendix in the current page. R Markdown creates IDs for all sections (and subsections) automatically, by converting to lower case and replacing spaces with dashes (-). But, you can explicitly set IDs too, by adding the ID with the # inside curly braces after the section heading. For instance you might prefer the shorter appen ID. You need to set it where the heading occurs: ## Appendix {#appen} Then you can link to it using this shorter ID elsewhere: See more details in the [appendix](#appen) You can also use this strategy to link to sections in other pages by including the relative URL first. For instance, to refer to this “Appendix” section from index.html you could include in index.Rmd: Some gory details of the analysis can also be found in the [Appendix of the report](report.html#appen) 6.5.5 Exercise: Add and link to a section in report.Rmd Add a new section to report.Rmd and include a link to it in index.Rmd. You’ll need to Knit both report.Rmd and index.Rmd, and commit and push the HTML files to check your work. 6.5.6 Including images Most of your images will likely be plots generated by R chunks in your R Markdown files and thus automatically included in the knitted HTML. If you want to display other images, you use the same syntax you saw in the Markdown section of the Reproducibility chapter chapter. That is, in your R Markdown file you’ll include the image with something like: ![Image caption here.](path/to/image/file.png) However, the path/to/image/file.png should be a relative URL pointing at an image in your docs/ directory. For example, if you had an image, me.png, inside an images directory inside your docs folder: ├── docs │ ├── index.Rmd │ ├── index.html │ ├── images │ │ └── me.png │ ├── report.Rmd │ └── report.html └── sharing-work.Rproj You could include it in index.html by adding to index.Rmd the line: ![A picture of me](images/me.png) Notice the syntax is very similar to adding a link to me.png: [A picture of me](images/me.png) Including the image displays the image inside at the appropriate place in the current page, linking to the image requires a viewer to click the link to see the image. Your image will be included at full size, but you might find it too large. You can additionally specify some attributes for the image in curly braces immediately following the link. For instance, use the width attribute to set the image width, either in pixels: [A picture of me](images/me.png){width=50} # default unit is px Or as a percentage: [A picture of me](images/me.png){width=50%} 6.5.7 Exercise: Add an image to index.html Include an image in your index.Rmd. (If you need an image to include you could always [build your own version of an Octocat][gh-myoctocat], GitHub’s mascot). Don’t forget, you’ll need to commit both your re-Knit index.html and your image. 6.6 Exercise: Add a website to an existing project Add a website to one of your existing project repositories. You’ll need to complete the following steps: Create a docs/ directory in your project. Add an index.Rmd R Markdown document to the docs/ folder and knit it to HTML to produce index.html. Commit these changes to git, and push to GitHub. Activate GitHub Pages in the repository settings with source set to “master branch /docs folder.” Visit the site to check it is working. "],["reproducibility.html", "Chapter 7 Reproducibility 7.1 Project organization 7.2 Reusability 7.3 Readability 7.4 Integrating text, code, and results 7.5 Key Points 7.6 Additional learning resources and material", " Chapter 7 Reproducibility There are several key cornerstones for doing rigorous and sound scientific research, two of which are reproducibility and replicability (Patil et al., 2016). Replicability is when a study is repeated by other independent research groups. [Reproducibility][sci-reproducibility] is when, given the same data and the same analytical/computational steps, a scientific result can be verified. Both of these concepts are surprisingly difficult to achieve. This course is about data analysis, so we’ll be focusing solely on reproducibility rather than replicability. At present, there is little effort in science for having research be reproducible, likely due in many ways to a lack of training and awareness. Being reproducible isn’t just about doing better science, it can also: Make you much more efficient and productive, as you spend less time between coding and putting your results in the document. Make you more confident in your results, since what you report and show as figures or tables will be exactly what you get from your analysis. No copying and pasting required! There are many aspects to reproducibility, such as: Organized files and folder, preferably based on a standard or conventional structure. Understandable and readable code that is documented and descriptive. Results from analyses are identical to results presented in scientific output (e.g. article, poster, slides). Results from analyses are identical when code is executed on other machines (results aren’t dependent on one computer). Explicit description or instruction on the order that code and scripts need to be executed. We’ll cover the first three items in this course. 7.1 Project organization First off, what exactly does “project” mean? That depends a bit on the group, individual, or situation, but for our purposes, a “project” is anything related to one or more completed scientific “products” (e.g. poster, slides, manuscript, package, teaching material) related to a specific question or goal. This could be “one manuscript publication and associated conference presentations” per project. Confining a project to one “scientific output” facilitates keeping the project reproducible is kept reproducible, all files will relate to that “output,” and can be easily archived once the manuscript has been published. However, this definition could be different depending on your own situation and goals. The ability to read, understand, modify, and write simple pieces of code is an essential skill for modern data analysis tasks and projects. Here we introduce you to some of the best practices one should have while writing their code. , many of which were taken from published “best practices” articles (Noble, 2009; Taschuk and Wilson, 2017; Wilson et al., 2017). Organise all R scripts and files in a single parent directory using a common and consistent folder and file structure. Use [version control][version-control] to track changes to files. Make raw data “read-only” (don’t edit it directly) and use code to show what was done. Write and describe code for people to read by being descriptive and using a [style guide][r-style-guide]. Think of code as part of your research product: Write for an audience or other reader. Create functions to avoid repetition. Whenever possible, use code to create output (figures, tables) rather than manualling creating or editing them. Managing your projects in a reproducible fashion doesn’t just make your science reproducible, it also makes your life easier! RStudio is here to help us with that by using [R Projects][rstudio-r-projects]. RStudio projects make it straightforward to divide your work into multiple contexts, each with their own working directory, workspace, history, and source documents. It is strongly recommended that you store all the necessary files that will be used in your code in the same parent directory. You can then use relative file paths to access them (we’ll talk about file paths below). This makes the directory and R Project a “product” or “bundle/package.” Like a tiny machine, that needs to have all its parts in the same place. 7.1.1 Creating your first project There are many ways one could organise a project folder. We’ll set up a project directory folder using the prodigenr package: # prodigenr::setup_project(&quot;ProjectName&quot;) prodigenr::setup_project(&quot;learningr&quot;) (You can also create a new project in RStudio by using “File -&gt; New Project -&gt;”Scientific Analysis Project using prodigenr\".) When we use the :: colon here, we are telling R “use setup_project function from the prodigenr package.” This function will then create the following folders and files: learningr ├── R │ ├── README.md │ ├── fetch_data.R │ └── setup.R ├── data │ └── README.md ├── doc │ └── README.md ├── .gitignore ├── DESCRIPTION ├── learningr.Rproj └── README.md This forces a specific, and consistent, folder structure to all your work. Think of this like the “introduction,” “methods,” “results,” and “discussion” sections of your paper. Each project is then like a single manuscript or report, that contains everything relevant to that specific project. There is a lot of power in something as simple as a consistent structure. Projects are used to make life easier. Once a project is opened within RStudio the following actions are taken: A new R session (process) is started. The current working directory is set to the project directory. RStudio project options are loaded. The README in each folder explains a bit about what should be placed there. But briefly: Documents like manuscripts, abstracts, and exploration type documents should be put in the doc/ directory (including [R Markdown][r-markdown] files which we will cover later). Data, raw data, and metadata should be in either the data/ directory or in data-raw/ for the raw data. All R files and code should be in the R/ directory. Name all new files to reflect their content or function. Follow the tidyverse [style guide for file naming][r-style-guide-files]. Note the DESCRIPTION file. This is used as metadata about the project and is useful when working on R projects. For any project, it is highly recommended to use version control. We’ll be covering version control in more detail later in the course. 7.1.2 Exercise: Better file naming Look at the list of file names below. Which file names are good names and which shouldn’t you use? fit models.R fit-models.R foo.r stuff.r get_data.R Manuscript version 10.docx manuscript.docx new version of analysis.R trying.something.here.R plotting-regression.R utility_functions.R code.R 7.1.3 Should you keep your data under version control? We have a data/ folder for a reason. But you might not want to keep the data under version control, for several reasons: It’s a large dataset (tens or more Mb in file size) There are sensitive and/or personally-identifying information in the data As a rule of thumb, if you can send the data by an email attachment, you could probably put it into Git. Unless there is sensitive or personal data, then don’t. If it isn’t kept under version control, make sure you include a reference to how or where you got the data, either as an R script showing the code you used to import/clean/download it or described in the README.md file. 7.2 Reusability Part of reproducibility is also making sure your scripts and file organization is “reusable” meaning that others (or yourself) can run it again. So, for instance, making sure to use “relative file paths” compared to “absolute file paths” (we’ll cover these in a bit). Or indicating which other R packages your code depends on. So here we’ll cover how to make sure your scripts and project files are reusable. 7.2.1 Keeping a clean slate When you finish writing your R code for the day and close the session, you probably will be asked about saving your session. What this does is everything kept in the [environment][environment] (e.g. all objects, functions, or datasets you created and used during the session) get saved to an .RData file. Then, the next time you open up your R session, R will see this .RData file and load everything in that file. Everything you did previously will be loaded into your environment. This seems like a good thing… but it’s not. Imagine eating your dinner on a really dirty plate… that’s not pleasant right? Loading a previous session is like that dirty plate. So, to make sure you always use a clean slate, we’ll run a handy function from the [usethis][usethis] package to stop R from saving and loading this .RData file, ensuring you have a clean working environment. You only need to run this function once, as it will set the appropriate RStudio settings for you. usethis::use_blank_slate() We’ll use the usethis package more throughout this chapter and others, as it provides several very useful functions when working with projects. 7.2.2 Packages, data, and file paths A major strength of R is in its ability for others to easily create packages that simplify doing complex tasks (e.g. creating figures with the [ggplot2][ggplot2] package) and for anyone to easily install and use that package1. You load a package by writing: library(tidyverse) Working with multiple R scripts and files, it quickly gets tedious to always write out each library function at the top of each script. A better way of managing this is to create a new file, keep all package loading code in that file, and sourcing that file in each R script. So, to create a new R file in the R/ folder, we’ll use this use_r() function from the usethis package: usethis::use_r(&quot;package-loading&quot;) This creates a file called package-loading.R in the R/ folder. In the package-loading.R file, add this code to it. library(tidyverse) Then in other R scripts in the R/, include this code at the top the script: source(here::here(&quot;R/package-loading.R&quot;)) The [here][r-here-pkg] package uses a function called here() that makes it easier to manage file paths. What is a file path and why is this necessary? A file path is the list of folders a file is found in. For instance, your resume may be found in /Users/Documents/personal_things/resume.docx. The problem with file paths in R is that when you run a script interactively (e.g. what we do in class and normally), the file path is located at the Project level (where the .Rproj file is found). You can see the file path by looking at the top of the “Console.” But! When you source() an R script, it may likely run in the folder it is saved in, e.g. in the R/ folder. So your file path R/packages-loading.R won’t work because there isn’t a folder called R in the R/ folder. Often people use the function setwd(), but this is never a good idea since using it makes your script runnable only on your computer… which makes it no longer reproducible. We use the here() function to tell R to go to the project root (where the .Rproj file is found) and then use the file path from that point. This simple function can make your work more reproducible and easier for you to use later on. We also use the here() function when we import a dataset or save a dataset. So, let’s load in the NYC Dog License dataset. First, save the CSV in the data/ folder. Then create a new R file: usethis::use_r(&quot;load-data&quot;) And write these lines in the file: source(here::here(&quot;R/package-loading.R&quot;)) dog_license &lt;- read_csv(here::here(&quot;data/nyc-dog-licenses.csv&quot;)) head(dog_license) That is how we will load data in from now on. Here are a few other tips for keeping your code reusable: When encountering a difficult problem, try to find R packages or functions that do your problem for you2. Split up your analyses steps into individual files (e.g. “model” file, “plot” file). Then source those files as needed or save the output in data/ to use it in other files. Try not to have R scripts be too long (e.g. more than 500 lines of code). Keep script sizes as small as necessary and as specific as possible (have a single purpose). A script should have an end goal. 7.3 Readability There are two reasons we write code: to instruct the computer to do something and to record the steps we took to get a particular result for us or others to understand. For computers, how or what you write doesn’t matter, as long as the code is correct. Computers don’t need to understand the code. But humans do need to understand it. We need clear language and explicit meaning in order to understand what is going on. Humans write code, humans read code, and humans must maintain it and fix any errors. So, what you write and how you write it is extremely important. Like natural human languages, R has a relaxed approached to how R code is written. This has some nice advantages, but also some major disadvantages, notably that writing styles can be quite different across the world or even within one’s own code. So, it’s important to stick to some guidelines, for instance, as laid out by the tidyverse [style guide][r-style-guide]. Some other tips include: Write your code assuming other people will be reading it. Stick to a [style guide][r-style-guide]. (We’re repeating this because it’s really important!) Use full and descriptive words when typing and creating objects. Use white space to separate concepts (empty lines between them, use spaces, and/or tabs). Use RStudio R Script Sections (\"Code-&gt;Insert Section\" or Ctrl-Shift-R) to separate content in scripts. Even though R doesn’t care about naming, spacing, and indenting, it really matters how your code looks. Coding is just like writing. Even though you may go through a brainstorming note-taking stage of writing, you eventually need to write correctly so others can understand, and read, what you are trying to say. Brainstorming and exploratory work is fine, but eventually you need to write code that will be legible. That’s why using a [style guide][r-style-guide] is really important. 7.3.1 Exercise: Make the code more readable Using the [style guide][r-style-guide] found in the link, try to make these code more readable. Edit the code so it follows the correct style and so it is easier to understand and read. You don’t need to understand what the code does, just follow the guide. # Object names DayOne dayone T &lt;- FALSE c &lt;- 9 mean &lt;- function(x) sum(x) # Spacing x[,1] x[ ,1] x[ , 1] mean (x, na.rm = TRUE) mean( x, na.rm = TRUE ) function (x) {} function(x){} height&lt;-feet*12+inches mean(x, na.rm=10) sqrt(x ^ 2 + y ^ 2) df $ z x &lt;- 1 : 10 # Indenting if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) FIXME: The below “details” will need to be dealt with since PDF doesn’t allow this FIXME: Maybe move to a solutions section at the end of chapter? Click for a possible solution The old code is in comments and the better code is below it. # Object names # Should be camel case # DayOne day_one # dayone day_one # Should not over write existing function names # T = TRUE, so don&#39;t name anything T # T &lt;- FALSE false &lt;- FALSE # c is a function name already. Plus c is not descriptive # c &lt;- 9 number_value &lt;- 9 # mean is a function, plus does not describe the function which is sum # mean &lt;- function(x) sum(x) sum_vector &lt;- function(x) sum(x) # Spacing # Commas should be in correct place # x[,1] # x[ ,1] # x[ , 1] x[, 1] # Spaces should be in correct place # mean (x, na.rm = TRUE) # mean( x, na.rm = TRUE ) mean(x, na.rm = TRUE) # function (x) {} # function(x){} function(x) {} # height&lt;-feet*12+inches height &lt;- feet * 12 + inches # mean(x, na.rm=10) mean(x, na.rm = 10) # sqrt(x ^ 2 + y ^ 2) sqrt(x^2 + y^2) # df $ z df$z # x &lt;- 1 : 10 x &lt;- 1:10 # Indenting should be done after if, for, else functions # if (y &lt; 0 &amp;&amp; debug) # message(&quot;Y is negative&quot;) if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) 7.3.2 Automatic styling with styler You may have organised the exercise by hand, but it’s possible to do it automatically. The tidyverse [style guide][r-style-guide] has been implemented into the [styler][styler-pkg] package to automate the process of following the guide by directly re-styling selected code. The styler snippets can be found in the Addins function in the RStudio “Addins” menu after you have installed it. RStudio also has its own automatic styling ability, through the menu item \"Code -&gt; Reformat Code\" (or Ctrl-Shift-A). Try both methods of styling on the exercise code above. There are slight differences in how each method works and they both aren’t always perfect. For now, let’s stick with using the styler package. The styler functions work on R code within both .R script files as well as R code within .Rmd documents, which we will cover later in this lesson. There are several styler RStudio addins, but we’ll focus on the two: \"Style selection\": Highlight text and click this button to reformat the code. \"Style active file\": Code in the .R or .Rmd file you have open and visible in RStudio will be reformatted when you click this button. There are two other styler functions that are also useful: styler::style_file(\"path/to/filename\"): Styles the whole file as indicated by the file path in the first argument. Can be either an .R or .Rmd file. styler::style_dir(\"directoryname\"): Styles all files in the indicated directory in the first argument. Let’s try the styler::style_file() function out. Inside a file called non-styled-code.R, it has: # Spacing x[,1] mean (x, na.rm = TRUE) function (x) {} height&lt;-feet*12+inches sqrt(x ^ 2 + y ^ 2) df $ z x &lt;- 1 : 10 # Indenting if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) Then we run: styler::style_file(&quot;testing-styler.R&quot;) Styling 1 files: testing-styler.R ℹ ──────────────────────────────────────── Status Count Legend ✔ 0 File unchanged. ℹ 1 File changed. ✖ 0 Styling threw an error. ──────────────────────────────────────── Please review the changes carefully! Which changes the file to be styled! # Spacing x[, 1] mean(x, na.rm = TRUE) function(x) {} height &lt;- feet * 12 + inches sqrt(x^2 + y^2) df$ z x &lt;- 1:10 # Indenting if (y &lt; 0 &amp;&amp; debug) { message(&quot;Y is negative&quot;) } This is more or less everything that the styler package does. 7.3.3 Exercise: Use styler to fix code formatting Use the styler package function on the code from the previous exercise by either running styler::style_file() or with the \"Style selection\" addin when highlighting the code. 7.4 Integrating text, code, and results The most obvious demonstration of reproducibility is when the results obtained from executing the analysis code (by an independent entity) are indentical to the results presented in the scientific output such as in an article. When there is agreement between these two, reproducibility has been more or less acheived. In R, there are tools available to completely ensure that this happens by directly inserting the results from the code into the scientific ouput. This is done by using [R Markdown][r-markdown], which interweaves R code with text. So instead of, for example, manually inserting a figure, you write R code within the document to insert the figure for you! Using [R Markdown][r-markdown] can save so much time and get your work that much closer to being reproducible. There are many other advantages to using R Markdown. From the single R Markdown format you can use it to create manuscripts, posters, slides, websites, books, and many more from simply using R Markdown. In fact, this book was written using R Markdown. As a bonus, switching between citation formats or Word templates for different journals is easier than doing it with Word. 7.4.1 Markdown R Markdown uses, well, Markdown as the format to convert to multiple document types. Fun fact: This website is built based on Markdown! While there are many “flavours” of Markdown that have been developed over the years, R Markdown uses the [Pandoc][pandoc-markdown] version. Pandoc is a combination of pan which is Latin for “all” and doc which means document. Markdown is a “markup language” meaning that special characters mean certain things, which we will cover below. To format text, such as to bold or make a list, you use the special characters. You write Markdown as plain text (like R code), so you don’t need any special software (like you do with Word documents). Most features needed for writing a scientific document are available in Markdown, but not all. Tip: Try to fit your writing and document creation around what Markdown can acheive, rather than force or fight Markdown to do something it wasn’t designed to do. All right, let’s create and save an R Markdown file. In RStudio, go to File -&gt; New File -&gt; R Markdown. A dialog box will pop up. In the “Title” section, type in Reproducible documents and in the “Author” section type in your name. Choose the HTML output format. Save this file as learning-rmarkdown.Rmd in the doc/ folder. Inside the file, there is a bunch of text that shows some basic formatting you can use for writing Markdown. For now, delete everything except the top part of the file (the part surrounded by ---). This part is called the YAML header, which we will cover more a bit later. Try converting the file to HTML by hitting the “Knit” button at the top or by typing out Ctrl-Shift-K. “Knit” button. 7.4.1.1 Headers Creating headers (like chapters or sections) is indicated by using one or more # at the beginning of a line, prefixing some text: # Header level 1 Paragraph. ## Header level 2 Paragraph. ### Header level 3 Paragraph. This creates the section headers as seen directly above (“Headers”) or below (“Text formatting”). The header text must be on one line, otherwise the next line is interpreted as paragraph text. See how it looks by “Knitting” the document (“Knit” button or Ctrl-Shift-K). 7.4.1.2 Text formatting To format text individually, surround the text with the special characters, as shown here: **bold** gives bold. *italics* gives italics. super^script^ gives superscript. sub~script~ gives subscript. What if you want to use the special character as simple text? Prefix it with an \\, so \\* becomes *, \\^ becomes ^, and \\~ becomes ~. 7.4.1.3 Lists To create an unnumbered list, do: - item 1 - item 2 - item 3 which gives… item 1 item 2 item 3 Notice the empty lines above and below the line, those are important. To create a numbered list, do: 1. item 1 2. item 2 3. item 3 which gives… item 1 item 2 item 3 See how it looks by “Knitting” the document (“Knit” button or Ctrl-Shift-K). 7.4.1.4 Blockquotes Sometimes (probably not too commonly), you may need to quote someone by using “blockquotes.” To do that, do: &gt; Blockquote which gives… Blockquote Blockquotes can be as many lines as you want. To stop a paragraph from being in the blockquote, separate the text with an empty line: &gt; Bockquote paragraph Regular paragraph 7.4.1.5 Adding footnotes Footnotes can be added by using [^some-text-label], such as: Footnote[^1] [^1]: Footnote content. which gives… Footnote3 So you can write some text, add some footnotes within, and include the footnote content right below the paragraph: Paragraph text[^1], with some more text[^reference]. [^1]: This is the first footnote. [^reference]: This is the next footnote. More paragraphs. Notice the empty lines in between. The footnote should also be on one line, though it isn’t strictly necessary. See how it looks by “Knitting” the document (“Knit” button or Ctrl-Shift-K). 7.4.1.6 Inserting pictures, images, or figures You can include externally created (i.e. not by an R code chunk, discussed later on) png, jpeg, or pdf image file by adding (: ![Image caption here.](path/to/image/file.png) So something like this: ![Steps to being more reproducible. Source DOI: 10.1038/d41586-018-05990-5](figures/reproducibility/code-sharing-steps.png) which gives… Steps to being more reproducible. Source DOI: 10.1038/d41586-018-05990-5 Tip: Can also include links to images from the Internet, as a URL link. If you want to modify the width or sizing, append something like {width=##%} to the end of the image insertion: ![Caption.](figures/reproducibility/code-sharing-steps.png){width=50%} which gives… Caption. 7.4.1.7 Adding links to websites And a link can be linked in the following format: [Link to GitHub](https://github.com). gives… Link to GitHub. The above form is great for one time use, but what if you want to use the same link again later on? Use this form then: Use multiple [links] in your document. The same [links] can be used again. [links]: https://github.com which gives… Use multiple links in your document. The same links can be used again. 7.4.1.8 Inserting (simple) tables You can insert tables with Markdown too. We wouldn’t recommend doing it for complicated tables though, as it can get tedious fast! (A recommended approach for more complex or bigger tables is to make the table contents as a data frame in R first and then use the knitr::kable() function to create the table, as we’ll cover in the R Markdown section below). You can even include Markdown text formatting inside the table: | | Fun | Serious | |:--|--:|:--:| | **Happy** | 1234 | 5678 | | **Sad** | 123 | 456 | which gives… Fun Serious Happy 1234 5678 Sad 123 456 The |--:| or |:--| tell the table to right-align or left-align, respectively, the values in the table column. Center-align is |:--:|. See how it looks by “Knitting” the document (“Knit” button or Ctrl-Shift-K). 7.4.1.9 Exercise: Try to re-create a document using Markdown Open this link. This is a HTML file that has been created by using Markdown formatting. Create a new R Markdown file, with output type “HTML,” and save it as mimic-html-file.Rmd. Delete all the automatically added text except the top part Inside the R Markdown file Write text using Markdown formatting so that you can create a html_document that looks exactly like the linked file. Knit the R Markdown document. Confirm that your version looks the same as the above version. 7.4.2 R Markdown [R Markdown][r-markdown] is an extension of Markdown that weaves together R code with Markdown formatted text all together in a single document. Output from the R code gets inserted directly into the document for a seamless integration of document writing and analysis reporting. 7.4.2.1 YAML header/metadata Most Markdown documents (especially for R Markdown) include YAML metadata at the top of the document, surrounded by ---. YAML is a data format, like CSV, that contains the metadata and various options that R Markdown uses for the entire document. Data in YAML is stored in the form variable: value. For instance, title or author is paired with their respective “values” and then used by Markdown when creating the document. Other options are also included here, such as what the converted output document should be, such as Word. There are many more output formats to choose from (e.g. slides, websites, books). The YAML header looks something like this: --- title: &quot;Document title&quot; author: Your Name output: html_document --- Here, there are three variable-value pairings: title, author, and output. In the output variable, the R Markdown function html_document is given so that the output document format is converted to HTML. There are also word_document and pdf_document settings. For now, we’ll focus on the html_document output. Usually when you create the R Markdown file, this YAML header gets added automatically. There are additional options you can set in the output field, which we will cover later on. 7.4.2.2 Using R code chunks R Markdown’s primary function is to allow combining text and R code in the same document, which is incredibly powerful and useful! All R code chunks have the appearance: ```{r chunk-label-name, chunk.option=&quot;...&quot;, chunk.option=...} ...R code... ``` Notice that chunk options need to be on the same line (one single line). Any R code in the code chunk gets evaluated and any output gets inserted into the document. So if the code prints to the console, it will get inserted into the document. The r tells R Markdown to run R on the code chunk, while the [chunk label][chunk-label] differentiates the chunk from other chunks. Using a chunk label also helps navigate a document when you use RStudio’s “Document outline” (Code -&gt; Show Document Outline). It also does a few other things. Note: Standard practice is that code [chunk labels][chunk-label] should be named without _, spaces, or . and instead should be one word or be separated by -. Let’s load in some packages and data: ```{r setup} library(tidyverse) co2_data &lt;- read_csv(here::here(&quot;data/co2.csv&quot;)) %&gt;% filter(co2_standard &gt; 0) ``` When running your code chunks interactively as you develop and write your document, R Markdown will look for a code chunk labeled setup to run first (for instance, to load all packages used in a document). Hence we name this chunk “setup.” 7.4.2.3 Inserting figures One of the most obvious benefits to using R Markdown is to automatically insert a plot. To do that we do: ```{r co2-time-plot} ggplot(co2_data, aes(x = year, y = co2_standard)) + geom_point() ``` What if we want to include the plot but not the code? Easy! Set the chunk option echo to FALSE: ```{r co2-time-plot, echo=FALSE} ggplot(co2_data, aes(x = year, y = co2_standard)) + geom_point() ``` Or what if you don’t want R to run the code chunk, but still show the code? Set the chunk option eval (for evaluate) to FALSE: ```{r co2-time-plot, eval=FALSE} ggplot(co2_data, aes(x = year, y = co2_standard)) + geom_point() ``` Since we have a figure, we can change some width, height, and alignment options, as well as add a caption with the fig.width, fig.height, fig.align, and fig.cap (respectively): ```{r co2-time-plot, fig.cap=&quot;Add your figure title here.&quot;, fig.height=4, fig.width=7} ggplot(co2_data, aes(x = year, y = co2_standard)) + geom_point() ``` ggplot(co2_data, aes(x = year, y = co2_standard)) + geom_point() Figure 7.1: Add your figure title here. What if we want to first run some code before running the plot, but don’t want to include the output of the other code? Make sure that the output doesn’t “print.” So letting R evaluate both dataframe and plot, the code chunk will output and insert both into the knitted document. ```{r co2-time-plot-after-2000-1, fig.cap=&quot;Add your figure title here.&quot;, fig.height=4, fig.width=7} co2_after_2000 &lt;- co2_data %&gt;% filter(year &gt;= 2000) # Print dataframe co2_after_2000 # Print plot ggplot(co2_after_2000, aes(x = year, y = co2_standard)) + geom_point() ``` ## # A tibble: 680 x 5 ## year month date_numeric co2_standard station ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2000 1 2000. 369. Mauna Loa, Hawaii, USA ## 2 2000 2 2000. 369. Mauna Loa, Hawaii, USA ## 3 2000 3 2000. 371. Mauna Loa, Hawaii, USA ## 4 2000 4 2000. 372. Mauna Loa, Hawaii, USA ## 5 2000 5 2000. 372. Mauna Loa, Hawaii, USA ## 6 2000 6 2000. 372. Mauna Loa, Hawaii, USA ## 7 2000 7 2001. 370. Mauna Loa, Hawaii, USA ## 8 2000 8 2001. 368. Mauna Loa, Hawaii, USA ## 9 2000 9 2001. 367. Mauna Loa, Hawaii, USA ## 10 2000 10 2001. 367. Mauna Loa, Hawaii, USA ## # … with 670 more rows Figure 7.2: Add your figure title here. Compare to this next code chunk, which will only output (“print”) the plot. See how we don’t include code that would send anything to the console to be “printed?” Only things that get “printed” will be included in the R Markdown output document. Also notice how we renamed the chunk label? In R Markdown you can’t have duplicate code chunk labels. ```{r co2-time-plot-after-2000-2, fig.cap=&quot;Add your figure title here.&quot;, fig.height=4, fig.width=7} co2_after_2000 &lt;- co2_data %&gt;% filter(year &gt;= 2000) # Print plot ggplot(co2_after_2000, aes(x = year, y = co2_standard)) + geom_point() ``` Figure 7.3: Add your figure title here. 7.4.2.4 Exercise: Add some figures to a R Markdown document Create a new R Markdown file (“File -&gt; New File -&gt; R Markdown”), providing the title, author name (your name), and setting the output to HTML. Save the file as using-rmarkdown.Rmd in the doc/ folder. Delete all text except the YAML header. Create an R code chunk and call the label “setup.” Write code so the packages and data are loaded. Create another code chunk and call it “plot-licenses-by-year.” Write R code to create a point plot (geom_point()) of the year on the x axis and number of licenses on the y axis. Knit the document and see what the output looks like. Change the theme of the plot to another builtin theme (hint: themes start with theme_). 7.4.2.5 Using R code chunks to insert tables You can also create tables by using the kable() function from the knitr package. Let’s create a table of the mean CO2 concentration over the years at each monthly period for each station. ```{r mean-co2-table} co2_data %&gt;% select(station, month, co2_standard) %&gt;% group_by(station, month) %&gt;% summarise(MeanCO2 = round(mean(co2_standard, na.rm = TRUE), 2)) %&gt;% spread(station, MeanCO2) %&gt;% knitr::kable(caption = &quot;Table caption here.&quot;) ``` ## `summarise()` has grouped output by &#39;station&#39;. You can override using the `.groups` argument. Table 7.1: Table caption here. month Alert Station, NWT, Canada Cape Grim, Tasmania, Australia Mauna Loa, Hawaii, USA 1 378.54 364.63 354.61 2 380.06 364.65 355.96 3 380.75 364.73 356.11 4 381.07 364.89 357.47 5 380.36 363.34 356.57 6 378.43 363.70 356.64 7 371.33 364.16 354.50 8 365.98 364.60 352.51 9 365.11 364.85 350.85 10 369.21 364.90 351.49 11 374.77 364.80 352.24 12 376.94 364.68 353.53 7.4.2.6 Inline R code Often you might have results inside the text you are writing. Here you can include R code within the text so that the results are inserted directly into the document. It looks like: The mean of CO2 is `r round(mean(co2_data$co2_standard, na.rm = TRUE), 2)`. Which gives… The mean of CO2 is round(mean(co2_data$co2_standard, na.rm = TRUE), 2). Keep in mind that inline R code can only insert a single number or character value, nothing more. 7.4.2.7 Citing literature with R Markdown No scientific writing is complete without being able to include references. If you want to insert a citation, use the Markdown key [@Cone2016], which will look like (Conery, 2016). The text Cone2016 is the key that the bibliography manager uses to identify a specific reference. Adding more references is done by separating by a ;, so like [@AuthorYear; @Author2Year; @Author3Year]. The resulting citation reference will be inserted at the bottom of the document. To get the bibliography to work, you’ll also need to add a line to the YAML header like this: --- title: &quot;My report&quot; author: &quot;Me!&quot; bibliography: my_references.bib --- The my_references.bib is a .bib file found in the same folder as the .Rmd file. So in our case, the .bib file is in the doc/ folder. You can also use other bibliography manager files, such as EndNote. See this documentation for which bibliography managers can be used. Since all references are appended to the bottom of the document, it’s good to add a final “Reference” section header to the end of your file, like so: # References 7.4.2.8 Making your report prettier This part mostly applies to HTML-based and PDF4 outputs, since programmatically modifying or setting templates in Word documents is rather difficult5. Changing broad features of a document can be done by setting the “theme” of the document. Add an option in the YAML metadata like: --- title: &quot;My report&quot; output: html_document: theme: sandstone --- Check out the R Markdown [documentation][rmd-themes] for more types of themes you can use for HTML documents, and advanced topics such as parameterized R Markdown documents. Most of the [Bootswatch][bootswatch] themes are available for use in R Markdown to HTML conversion. Want to add a Table of Contents? Easy! Add toc: true to the YAML header: --- title: &quot;My report&quot; output: html_document: theme: sandstone toc: true --- Adding a toc only works for PDF and HTML, but not Word documents. 7.4.2.9 Exercise: Add a summary table, inline results, and a prettier theme Use the R Markdown file from the previous exercise (using-rmarkdown.Rmd). Create three new header 1 # sections: Objective, Results, Conclusion. Write in the “Objective” section an idea you have about the Dog License dataset. It can be as simple as “How many dogs are there in New Year City?” Include an italics in this sentence. Create three new code chunks in the “Results” section: One for setup, one for plot-dogs, and one for table-dogs. Write R code to load the packages and data in the setup chunk. Knit the document to see what it looks like. Write R code to create a simple ggplot2 plot in the plot-dogs chunk related to your “Objective.” Knit the document to see what it looks like. Write R code to create a simple summary table using kable() in the table-dogs chunk related to your “Objective.” Knit the document to see what it looks like. Write an observation you made about the data from the plot and table in the “Conclusions” section. Include a bold text in this section. Check out the [Bootswatch][bootswatch] themes and change your HTML theme to something else and add a Table of Contents. 7.5 Key Points A structured and standard project folder and file layout is the first step to having a reproducible data analysis project. Writing documents in R Markdown can reduce the time spent on manual tasks since results can be easily re-generated and inserted into the final document to improve reproducibility. usethis has several helper functions for managing data analysis projects. Following a style guide and emphasizing readable code can lead to better quality code and to code that is more likely to be reproducible and reusable. Using Markdown to write documents is a great way to improve accessibility (since it is plain text only) and allows you to generate multiple types of output (HTML, PDF, slides, etc) from a single document source. 7.6 Additional learning resources and material For learning: Use other programming languages in an R Markdown document. Online book for R Markdown R Markdown chapter in the R for Data Science book. For help: RStudio helpful cheatsheets R Markdown cheatsheet (downloads a pdf file) R Markdown reference cheatsheet Note: Source material for this chapter was modified from https://rqawr-course.lwjohnst.com/, as well as many other resources (see https://rqawr-course.lwjohnst.com/license/). You may encounter some who say you shouldn’t rely on packages and to only use base R functions. However, this is seriously bad advice since the ecosystem of R packages can greatly simplify your life doing data analysis. Plus, packages greatly expand and enhance the capability of R, so make use of packages! If someone invents a wheel, why wouldn’t you use it?↩︎ You may hear some people say “oh, don’t bother with R packages, do everything in base R”… don’t listen to them. Do you build a computer from scratch everytime you want to do any type of work? Or a car when you want to drive somewhere? No, you don’t. Make use of other people’s hard work to make tools that simplify your life.↩︎ Footnote content.↩︎ Knitting to PDF requires LaTeX, which you can install from [tinytex][tinytex]. After you install LaTeX you can create truly beautifully typeset PDF documents.↩︎ If you really want to do it, the best way is to create your template in the .odt, and then convert to .docx.↩︎ "],["license.html", "A License", " A License This is a human-readable summary of (and not a substitute for) the license. Please see https://creativecommons.org/licenses/by/4.0/legalcode for the full legal text. This work is licensed under the Creative Commons Attribution 4.0 International license (CC-BY-4.0). You are free to: Share—copy and redistribute the material in any medium or format Remix—remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution—You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions—You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Notices: You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material. "],["conduct.html", "B Code of Conduct B.1 Our Standards B.2 Our Responsibilities B.3 Scope B.4 Enforcement B.5 Attribution", " B Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. B.1 Our Standards Examples of behavior that contributes to creating a positive environment include: using welcoming and inclusive language, being respectful of differing viewpoints and experiences, gracefully accepting constructive criticism, focusing on what is best for the community, and showing empathy towards other community members. Examples of unacceptable behavior by participants include: the use of sexualized language or imagery and unwelcome sexual attention or advances, trolling, insulting/derogatory comments, and personal or political attacks, public or private harassment, publishing others’ private information, such as a physical or electronic address, without explicit permission, and other conduct which could reasonably be considered inappropriate in a professional setting B.2 Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. B.3 Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. B.4 Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by emailing the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership. B.5 Attribution This Code of Conduct is adapted from the Contributor Covenant version 1.4. "],["glossary.html", "C Glossary", " C Glossary Abandonware FIXME Absolute error FIXME Absolute import FIXME Absolute path Refers to the complete listing of folders between the root folder to the last folder, if the path points to a folder, or to the parent folder, if the path points to a file. Actual result FIXME Agile development FIXME Ally FIXME Append mode FIXME Assertion FIXME Authentic task A task which contains important elements of things that learners would do in real (non-classroom situations). To be authentic, a task should require learners to construct their own answers rather than choose between provided answers, and to work with the same tools and data they would use in real life. Auto-completion Is a feature that allows the user to finish a word or code quickly through the use of hitting the TAB key to list possible words or code that the user can select from. Automatic variable (in Make) FIXME Boilerplate FIXME Branch-per-feature workflow FIXME https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow Bug report Is a collection of files, logs, or related information that adequately describes either an unexpected output of some code or program or an unexpected error or warning. This information is used to help find and fix a bug in the program or code. Bug tracker Is a system that tracks and manages reported bugs for a software program, to make it easier to address and fix the bugs. Build manager FIXME https://en.wikipedia.org/wiki/List_of_build_automation_software Byte code FIXME Call stack FIXME Camel case A style of writing code that involves naming variables and objects with no space, underscore (_), dot (.), or dash (-), with each word being capitalized. Some examples would be: CalculateSum, findPattern, SearchFiles, or objectNumber. Catch (an exception) FIXME Checking-driven development (CDD) FIXME Checklist FIXME Code review FIXME Cognitive load FIXME Command argument FIXME Command flag FIXME Command history FIXME Command option FIXME Command shell FIXME Command switch FIXME Command-line interface (CLI) FIXME Comment Is text written in a script that is not treated as code to be run, but rather as text that describes what the code is doing. These are usually short notes, often beginning with a # (in many programming languages). Commit FIXME: define both noun and verb. Commit message FIXME Commons FIXME Competent practitioner Someone who can do normal tasks with normal effort under normal circumstances. See also novice and expert. Compiled language FIXME Compiler FIXME Computational notebook FIXME Conditional expression FIXME Confirmation bias Is the tendency to seek out or interpret information that re-affirms or supports one’s pre-existing knowledge, beliefs, or values. Continuation prompt FIXME Continuous integration FIXME Coverage FIXME Creative Commons - Attribution License (CC-BY) FIXME Current working directory The folder or directory location that the program is operating in. Any action taken by the program occurs relative to this directory. Data package A software package that, mostly, contains only data. Is used to make it simpler to disseminate data for easier use. Default target (in Make) FIXME Defensive programming FIXME Destructuring FIXME Dictionary FIXME Digital Object Identifier (DOI) FIXME Docstring FIXME Documentation generator FIXME Down-vote FIXME Entry point FIXME Exception FIXME Expected result FIXME Expert Someone who can diagnose and handle unusual situations, knows when the usual rules do not apply, and tends to recognize solutions rather than reasoning to them. See also competent practitioner and novice. Explicit relative import FIXME Exploratory programming FIXME Export a variable FIXME External error FIXME False beginner Someone who has studied a language before but is learning it again. False beginners start at the same point as true beginners (i.e., a pre-test will show the same proficiency) but can move much more quickly. Feature request Is a request to the maintainers or developers of a software program to add a specific functionality (a feature) to that program. Filename extension FIXME Filename stem FIXME Filesystem Controls how files are stored and retrieved on disk by an operating system. Also used to refer to the disk that is used to store the files or the type of the filesystem. Filter FIXME Fixture FIXME Flag variable FIXME Folder Is a computer storage and organization concept that allows files to be organized in a common location, which is the folder or directory. A folder can store both files and other folders. Forge FIXME Frequently Asked Questions (FAQ) FIXME Full identifier (in Git) FIXME Function (in Make) FIXME GNU Public License (GPL) FIXME Git Is a software program that formally tracks changes made to a collection of files within a specific folder (and its subfolders). Technically, Git is a “distributed version control system,” meaning that each user who has a repository on their computer also has the entire history of changes made to that repository, so that technically there is no central repository (e.g. that is only accessible on a server). Git branch FIXME Git clone Copies, and usually downloads, a Git remote repository onto the local computer. Git conflict FIXME Git fork Is a concept in GitHub that indicates a GitHub repository has been cloned into a new GitHub repository. Git merge FIXME Git pull Downloads and synchronizes changes between a remote repository and a local repository. Git push Uploads and synchronizes changes between a local repository and a remote repository. Git stage FIXME Git FIXME Graphical user interface (GUI) FIXME Hitchhiker FIXME Home directory FIXME Governance FIXME ISO date format FIXME Impact/effort matrix FIXME Implicit relative import FIXME Impostor syndrome FIXME In-place operator FIXME Internal error FIXME Interpeter FIXME Interpreted language FIXME Interruption bingo FIXME Integration testing FIXME Invariant FIXME Issue tracking system Is similar to a bug tracking system in that it tracks “issues” made to a repository, usually in the form of feature requests, bug reports, or some other todo item. Issue FIXME JSON FIXME Kebab case FIXME Label (in issue tracker) FIXME Label (in issue tracker) FIXME LaTeX FIXME Linter FIXME List comprehension FIXME Logging framework FIXME Long option FIXME Loop body FIXME Loop (in Unix) FIXME Milestone FIXME MIT License Is a legal license that places very limited restrictions on the re-use of software, making it a very permissive license that encourages using, modifying, and distributing the software widely. Magic number FIXME Makefile FIXME Martha’s Rules FIXME Maximum likelihood extimation FIXME Mental model A simplified representation of the key elements and relationships of some problem domain that is good enough to support problem solving. Nano FIXME Ngo FIXME Novice Someone who has not yet built a usable mental model of a domain. See also competent practitioner and expert. Object-oriented programming FIXME Open license Is a legal license that encourages, rather than restricts, the use, re-use, modification, and distribution of a copyrighted material, such as with software or written text. Open science FIXME Operating system FIXME Oppression FIXME Optional argument FIXME Orthogonality FIXME Overlay configuration FIXME Pager FIXME Parent directory FIXME Patch FIXME Path coverage FIXME Path FIXME Pattern rule FIXME Phony target FIXME Pipe (in Unix) FIXME Positional argument FIXME Postcondition FIXME Pothole case FIXME Power law FIXME Precondition FIXME Prerequisite (in Make) FIXME Privilege FIXME Procedural programming FIXME Process FIXME Product manager FIXME Project manager FIXME Prompt FIXME Provenance FIXME Public domain license (CC-0) FIXME Pull request FIXME Python FIXME Raise FIXME Raster image FIXME Recursion FIXME Redirection FIXME Refactoring FIXME Regression testing FIXME Regression FIXME Regular expression a sequence of characters that define a pattern that can be used to find matching strings Relative error FIXME Relative path Is a reference to a folder or file that begins at the current working directory, unlike an absolute path that starts with the root directory. Remote login FIXME Remote login server FIXME Remote repository FIXME Repl FIXME Repository FIXME Reproducible example (reprex) A way of showing a code example that demonstrates the usage of the code or to highlight an error or bug that easily allows another user to re-create (“reproduce”) the same output or error. Reproducible research A central pillar of rigorous research that involves describing and documenting the research results in such a way that another researcher or person can re-run the analysis code on the exact data to obtain the same result, to “reproduce” the findings. Research software engineer (RSE) FIXME Restructured Text (reST) A plain text markup language used by much Python documentation and documentation tooling. Revision FIXME Root directory The root folder is the folder that contains all folders and files on the computer. It is the starting point to all files and is essentially referring to the hard drive itself. An analogy to the root directory would be that it is the trunk of a tree and all other folders are branches from that trunk. Rotating file FIXME Rule (in Make) FIXME Secure Shell (SSH) FIXME SSH daemon FIXME SSH key FIXME SSH protocol FIXME Script FIXME Search path FIXME Semantic versioning FIXME https://semver.org/ Sense vote FIXME Shebang FIXME Shell script FIXME Short circuit test FIXME Short identifier (in Git) FIXME Short option FIXME Snake case FIXME Source distribution FIXME Sprint FIXME Standard error FIXME Standard input FIXME Standard input FIXME Standard output FIXME Standard output FIXME Stop word FIXME Subcommand FIXME Subdirectory FIXME Sustainable software FIXME Tab completion FIXME Tag FIXME Target FIXME Target (in Make) FIXME Ternary expression FIXME Test framework FIXME Test runner FIXME Test-driven development FIXME Three stickies FIXME Ticket FIXME Ticketing system FIXME Tidy data As defined in Wickham (2014), tabular data is tidy if (1) each variable is in one column, (2) each different observation of that variable is in a different row, (3) there is one table for each kind of variable, and (4) if there are multiple tables, each includes a key so that related data can be linked. Timestamp (on a file) FIXME Tolerance FIXME Transitive dependency FIXME Triage FIXME Tuple FIXME Unit test FIXME Unix shell FIXME Up-vote FIXME Update operator See in-place operator. Validation FIXME Variable (in Make) FIXME Verification FIXME Version control system FIXME Virtual environment In Python, the virtualenv package allows you to create virtual, disposable, Python software environments containing only the packages and versions of packages you want to use for a particular project or task, and to install new packages into the environment without affecting other virtual environments or the system-wide default environment. Virtual machine A program that pretends to be a computer. This may seem a bit redundant, but VMs are quick to create and start up, and changes made inside the virtual machine are contained within that VM so we can install new packages or run a completely different operating system without affecting the underlying computer. Whitespace FIXME Wildcard FIXME Working memory FIXME Wrap code FIXME "],["objectives.html", "D Novice R Learning Objectives", " D Novice R Learning Objectives This appendix lays out the learning objectives for each set of lessons, and is intended to help instructors who want to use this curriculum. FIXME: learning objectives for novice R. "],["keypoints.html", "E Novice R Key Points", " E Novice R Key Points FIXME: fill in keypoints for novice R "],["references.html", "References", " References "]]
